diff -Naur linux-3.5.4/arch/mips/alchemy/board-mtx1.c linux-2012.09/arch/mips/alchemy/board-mtx1.c
--- linux-3.5.4/arch/mips/alchemy/board-mtx1.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/alchemy/board-mtx1.c	2012-10-27 16:24:00.000000000 +0800
@@ -228,8 +228,6 @@
 	 * adapter on the mtx-1 "singleboard" variant. It triggers a custom
 	 * logic chip connected to EXT_IO3 (GPIO1) to suppress IDSEL signals.
 	 */
-	udelay(1);
-
 	if (assert && devsel != 0)
 		/* Suppress signal to Cardbus */
 		alchemy_gpio_set_value(1, 0);	/* set EXT_IO3 OFF */
diff -Naur linux-3.5.4/arch/mips/bcm63xx/boards/board_bcm963xx.c linux-2012.09/arch/mips/bcm63xx/boards/board_bcm963xx.c
--- linux-3.5.4/arch/mips/bcm63xx/boards/board_bcm963xx.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/bcm63xx/boards/board_bcm963xx.c	2012-10-27 16:24:02.000000000 +0800
@@ -25,7 +25,6 @@
 #include <bcm63xx_dev_enet.h>
 #include <bcm63xx_dev_dsp.h>
 #include <bcm63xx_dev_pcmcia.h>
-#include <bcm63xx_dev_spi.h>
 #include <board_bcm963xx.h>
 
 #define PFX	"board_bcm963xx: "
@@ -891,8 +890,6 @@
 	}
 #endif
 
-	bcm63xx_spi_register();
-
 	/* read base address of boot chip select (0) */
 	val = bcm_mpi_readl(MPI_CSBASE_REG(0));
 	val &= MPI_CSBASE_BASE_MASK;
diff -Naur linux-3.5.4/arch/mips/bcm63xx/clk.c linux-2012.09/arch/mips/bcm63xx/clk.c
--- linux-3.5.4/arch/mips/bcm63xx/clk.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/bcm63xx/clk.c	2012-10-27 16:24:02.000000000 +0800
@@ -120,7 +120,7 @@
 {
 	if (!BCMCPU_IS_6368())
 		return;
-	bcm_hwclock_set(CKCTL_6368_ROBOSW_EN |
+	bcm_hwclock_set(CKCTL_6368_ROBOSW_CLK_EN |
 			CKCTL_6368_SWPKT_USB_EN |
 			CKCTL_6368_SWPKT_SAR_EN, enable);
 	if (enable) {
@@ -163,7 +163,7 @@
 	if (BCMCPU_IS_6348())
 		bcm_hwclock_set(CKCTL_6348_USBH_EN, enable);
 	else if (BCMCPU_IS_6368())
-		bcm_hwclock_set(CKCTL_6368_USBH_EN, enable);
+		bcm_hwclock_set(CKCTL_6368_USBH_CLK_EN, enable);
 }
 
 static struct clk clk_usbh = {
@@ -181,11 +181,9 @@
 		mask = CKCTL_6338_SPI_EN;
 	else if (BCMCPU_IS_6348())
 		mask = CKCTL_6348_SPI_EN;
-	else if (BCMCPU_IS_6358())
-		mask = CKCTL_6358_SPI_EN;
 	else
-		/* BCMCPU_IS_6368 */
-		mask = CKCTL_6368_SPI_EN;
+		/* BCMCPU_IS_6358 */
+		mask = CKCTL_6358_SPI_EN;
 	bcm_hwclock_set(mask, enable);
 }
 
@@ -201,7 +199,7 @@
 	if (!BCMCPU_IS_6368())
 		return;
 
-	bcm_hwclock_set(CKCTL_6368_SAR_EN |
+	bcm_hwclock_set(CKCTL_6368_SAR_CLK_EN |
 			CKCTL_6368_SWPKT_SAR_EN, enable);
 
 	if (enable) {
diff -Naur linux-3.5.4/arch/mips/bcm63xx/dev-dsp.c linux-2012.09/arch/mips/bcm63xx/dev-dsp.c
--- linux-3.5.4/arch/mips/bcm63xx/dev-dsp.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/bcm63xx/dev-dsp.c	2012-10-27 16:24:02.000000000 +0800
@@ -31,7 +31,7 @@
 
 static struct platform_device bcm63xx_voip_dsp_device = {
 	.name		= "bcm63xx-voip-dsp",
-	.id		= -1,
+	.id		= 0,
 	.num_resources	= ARRAY_SIZE(voip_dsp_resources),
 	.resource	= voip_dsp_resources,
 };
diff -Naur linux-3.5.4/arch/mips/bcm63xx/dev-spi.c linux-2012.09/arch/mips/bcm63xx/dev-spi.c
--- linux-3.5.4/arch/mips/bcm63xx/dev-spi.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/bcm63xx/dev-spi.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,119 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 2009-2011 Florian Fainelli <florian@openwrt.org>
- * Copyright (C) 2010 Tanguy Bouzeloc <tanguy.bouzeloc@efixo.com>
- */
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/export.h>
-#include <linux/platform_device.h>
-#include <linux/err.h>
-#include <linux/clk.h>
-
-#include <bcm63xx_cpu.h>
-#include <bcm63xx_dev_spi.h>
-#include <bcm63xx_regs.h>
-
-#ifdef BCMCPU_RUNTIME_DETECT
-/*
- * register offsets
- */
-static const unsigned long bcm6338_regs_spi[] = {
-	__GEN_SPI_REGS_TABLE(6338)
-};
-
-static const unsigned long bcm6348_regs_spi[] = {
-	__GEN_SPI_REGS_TABLE(6348)
-};
-
-static const unsigned long bcm6358_regs_spi[] = {
-	__GEN_SPI_REGS_TABLE(6358)
-};
-
-static const unsigned long bcm6368_regs_spi[] = {
-	__GEN_SPI_REGS_TABLE(6368)
-};
-
-const unsigned long *bcm63xx_regs_spi;
-EXPORT_SYMBOL(bcm63xx_regs_spi);
-
-static __init void bcm63xx_spi_regs_init(void)
-{
-	if (BCMCPU_IS_6338())
-		bcm63xx_regs_spi = bcm6338_regs_spi;
-	if (BCMCPU_IS_6348())
-		bcm63xx_regs_spi = bcm6348_regs_spi;
-	if (BCMCPU_IS_6358())
-		bcm63xx_regs_spi = bcm6358_regs_spi;
-	if (BCMCPU_IS_6368())
-		bcm63xx_regs_spi = bcm6368_regs_spi;
-}
-#else
-static __init void bcm63xx_spi_regs_init(void) { }
-#endif
-
-static struct resource spi_resources[] = {
-	{
-		.start		= -1, /* filled at runtime */
-		.end		= -1, /* filled at runtime */
-		.flags		= IORESOURCE_MEM,
-	},
-	{
-		.start		= -1, /* filled at runtime */
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct bcm63xx_spi_pdata spi_pdata = {
-	.bus_num		= 0,
-	.num_chipselect		= 8,
-};
-
-static struct platform_device bcm63xx_spi_device = {
-	.name		= "bcm63xx-spi",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(spi_resources),
-	.resource	= spi_resources,
-	.dev		= {
-		.platform_data = &spi_pdata,
-	},
-};
-
-int __init bcm63xx_spi_register(void)
-{
-	struct clk *periph_clk;
-
-	if (BCMCPU_IS_6345())
-		return -ENODEV;
-
-	periph_clk = clk_get(NULL, "periph");
-	if (IS_ERR(periph_clk)) {
-		pr_err("unable to get periph clock\n");
-		return -ENODEV;
-	}
-
-	/* Set bus frequency */
-	spi_pdata.speed_hz = clk_get_rate(periph_clk);
-
-	spi_resources[0].start = bcm63xx_regset_address(RSET_SPI);
-	spi_resources[0].end = spi_resources[0].start;
-	spi_resources[1].start = bcm63xx_get_irq_number(IRQ_SPI);
-
-	if (BCMCPU_IS_6338() || BCMCPU_IS_6348()) {
-		spi_resources[0].end += BCM_6338_RSET_SPI_SIZE - 1;
-		spi_pdata.fifo_size = SPI_6338_MSG_DATA_SIZE;
-	}
-
-	if (BCMCPU_IS_6358() || BCMCPU_IS_6368()) {
-		spi_resources[0].end += BCM_6358_RSET_SPI_SIZE - 1;
-		spi_pdata.fifo_size = SPI_6358_MSG_DATA_SIZE;
-	}
-
-	bcm63xx_spi_regs_init();
-
-	return platform_device_register(&bcm63xx_spi_device);
-}
diff -Naur linux-3.5.4/arch/mips/bcm63xx/dev-wdt.c linux-2012.09/arch/mips/bcm63xx/dev-wdt.c
--- linux-3.5.4/arch/mips/bcm63xx/dev-wdt.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/bcm63xx/dev-wdt.c	2012-10-27 16:24:02.000000000 +0800
@@ -21,7 +21,7 @@
 
 static struct platform_device bcm63xx_wdt_device = {
 	.name		= "bcm63xx-wdt",
-	.id		= -1,
+	.id		= 0,
 	.num_resources	= ARRAY_SIZE(wdt_resources),
 	.resource	= wdt_resources,
 };
diff -Naur linux-3.5.4/arch/mips/bcm63xx/Makefile linux-2012.09/arch/mips/bcm63xx/Makefile
--- linux-3.5.4/arch/mips/bcm63xx/Makefile	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/bcm63xx/Makefile	2012-10-27 16:24:02.000000000 +0800
@@ -1,6 +1,5 @@
 obj-y		+= clk.o cpu.o cs.o gpio.o irq.o prom.o setup.o timer.o \
-		   dev-dsp.o dev-enet.o dev-pcmcia.o dev-spi.o dev-uart.o \
-		   dev-wdt.o
+		   dev-dsp.o dev-enet.o dev-pcmcia.o dev-uart.o dev-wdt.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 
 obj-y		+= boards/
diff -Naur linux-3.5.4/arch/mips/cavium-octeon/executive/cvmx-fpa.c linux-2012.09/arch/mips/cavium-octeon/executive/cvmx-fpa.c
--- linux-3.5.4/arch/mips/cavium-octeon/executive/cvmx-fpa.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2012.09/arch/mips/cavium-octeon/executive/cvmx-fpa.c	2012-10-27 16:24:01.000000000 +0800
@@ -0,0 +1,183 @@
+/***********************license start***************
+ * Author: Cavium Networks
+ *
+ * Contact: support@caviumnetworks.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2008 Cavium Networks
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Networks for more information
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Support library for the hardware Free Pool Allocator.
+ *
+ *
+ */
+
+#include "cvmx-config.h"
+#include "cvmx.h"
+#include "cvmx-fpa.h"
+#include "cvmx-ipd.h"
+
+/**
+ * Current state of all the pools. Use access functions
+ * instead of using it directly.
+ */
+CVMX_SHARED cvmx_fpa_pool_info_t cvmx_fpa_pool_info[CVMX_FPA_NUM_POOLS];
+
+/**
+ * Setup a FPA pool to control a new block of memory. The
+ * buffer pointer must be a physical address.
+ *
+ * @pool:       Pool to initialize
+ *                   0 <= pool < 8
+ * @name:       Constant character string to name this pool.
+ *                   String is not copied.
+ * @buffer:     Pointer to the block of memory to use. This must be
+ *                   accessible by all processors and external hardware.
+ * @block_size: Size for each block controlled by the FPA
+ * @num_blocks: Number of blocks
+ *
+ * Returns 0 on Success,
+ *         -1 on failure
+ */
+int cvmx_fpa_setup_pool(uint64_t pool, const char *name, void *buffer,
+			uint64_t block_size, uint64_t num_blocks)
+{
+	char *ptr;
+	if (!buffer) {
+		cvmx_dprintf
+		    ("ERROR: cvmx_fpa_setup_pool: NULL buffer pointer!\n");
+		return -1;
+	}
+	if (pool >= CVMX_FPA_NUM_POOLS) {
+		cvmx_dprintf("ERROR: cvmx_fpa_setup_pool: Illegal pool!\n");
+		return -1;
+	}
+
+	if (block_size < CVMX_FPA_MIN_BLOCK_SIZE) {
+		cvmx_dprintf
+		    ("ERROR: cvmx_fpa_setup_pool: Block size too small.\n");
+		return -1;
+	}
+
+	if (((unsigned long)buffer & (CVMX_FPA_ALIGNMENT - 1)) != 0) {
+		cvmx_dprintf
+		    ("ERROR: cvmx_fpa_setup_pool: Buffer not aligned properly.\n");
+		return -1;
+	}
+
+	cvmx_fpa_pool_info[pool].name = name;
+	cvmx_fpa_pool_info[pool].size = block_size;
+	cvmx_fpa_pool_info[pool].starting_element_count = num_blocks;
+	cvmx_fpa_pool_info[pool].base = buffer;
+
+	ptr = (char *)buffer;
+	while (num_blocks--) {
+		cvmx_fpa_free(ptr, pool, 0);
+		ptr += block_size;
+	}
+	return 0;
+}
+
+/**
+ * Shutdown a Memory pool and validate that it had all of
+ * the buffers originally placed in it.
+ *
+ * @pool:   Pool to shutdown
+ * Returns Zero on success
+ *         - Positive is count of missing buffers
+ *         - Negative is too many buffers or corrupted pointers
+ */
+uint64_t cvmx_fpa_shutdown_pool(uint64_t pool)
+{
+	uint64_t errors = 0;
+	uint64_t count = 0;
+	uint64_t base = cvmx_ptr_to_phys(cvmx_fpa_pool_info[pool].base);
+	uint64_t finish =
+	    base +
+	    cvmx_fpa_pool_info[pool].size *
+	    cvmx_fpa_pool_info[pool].starting_element_count;
+	void *ptr;
+	uint64_t address;
+
+	count = 0;
+	do {
+		ptr = cvmx_fpa_alloc(pool);
+		if (ptr)
+			address = cvmx_ptr_to_phys(ptr);
+		else
+			address = 0;
+		if (address) {
+			if ((address >= base) && (address < finish) &&
+			    (((address -
+			       base) % cvmx_fpa_pool_info[pool].size) == 0)) {
+				count++;
+			} else {
+				cvmx_dprintf
+				    ("ERROR: cvmx_fpa_shutdown_pool: Illegal address 0x%llx in pool %s(%d)\n",
+				     (unsigned long long)address,
+				     cvmx_fpa_pool_info[pool].name, (int)pool);
+				errors++;
+			}
+		}
+	} while (address);
+
+#ifdef CVMX_ENABLE_PKO_FUNCTIONS
+	if (pool == 0)
+		cvmx_ipd_free_ptr();
+#endif
+
+	if (errors) {
+		cvmx_dprintf
+		    ("ERROR: cvmx_fpa_shutdown_pool: Pool %s(%d) started at 0x%llx, ended at 0x%llx, with a step of 0x%llx\n",
+		     cvmx_fpa_pool_info[pool].name, (int)pool,
+		     (unsigned long long)base, (unsigned long long)finish,
+		     (unsigned long long)cvmx_fpa_pool_info[pool].size);
+		return -errors;
+	} else
+		return 0;
+}
+
+uint64_t cvmx_fpa_get_block_size(uint64_t pool)
+{
+	switch (pool) {
+	case 0:
+		return CVMX_FPA_POOL_0_SIZE;
+	case 1:
+		return CVMX_FPA_POOL_1_SIZE;
+	case 2:
+		return CVMX_FPA_POOL_2_SIZE;
+	case 3:
+		return CVMX_FPA_POOL_3_SIZE;
+	case 4:
+		return CVMX_FPA_POOL_4_SIZE;
+	case 5:
+		return CVMX_FPA_POOL_5_SIZE;
+	case 6:
+		return CVMX_FPA_POOL_6_SIZE;
+	case 7:
+		return CVMX_FPA_POOL_7_SIZE;
+	default:
+		return 0;
+	}
+}
diff -Naur linux-3.5.4/arch/mips/cavium-octeon/executive/cvmx-helper-fpa.c linux-2012.09/arch/mips/cavium-octeon/executive/cvmx-helper-fpa.c
--- linux-3.5.4/arch/mips/cavium-octeon/executive/cvmx-helper-fpa.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2012.09/arch/mips/cavium-octeon/executive/cvmx-helper-fpa.c	2012-10-27 16:24:01.000000000 +0800
@@ -0,0 +1,243 @@
+/***********************license start***************
+ * Author: Cavium Networks
+ *
+ * Contact: support@caviumnetworks.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2008 Cavium Networks
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Networks for more information
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Helper functions for FPA setup.
+ *
+ */
+#include "executive-config.h"
+#include "cvmx-config.h"
+#include "cvmx.h"
+#include "cvmx-bootmem.h"
+#include "cvmx-fpa.h"
+#include "cvmx-helper-fpa.h"
+
+/**
+ * Allocate memory for and initialize a single FPA pool.
+ *
+ * @pool:    Pool to initialize
+ * @buffer_size:  Size of buffers to allocate in bytes
+ * @buffers: Number of buffers to put in the pool. Zero is allowed
+ * @name:    String name of the pool for debugging purposes
+ * Returns Zero on success, non-zero on failure
+ */
+static int __cvmx_helper_initialize_fpa_pool(int pool, uint64_t buffer_size,
+					     uint64_t buffers, const char *name)
+{
+	uint64_t current_num;
+	void *memory;
+	uint64_t align = CVMX_CACHE_LINE_SIZE;
+
+	/*
+	 * Align the allocation so that power of 2 size buffers are
+	 * naturally aligned.
+	 */
+	while (align < buffer_size)
+		align = align << 1;
+
+	if (buffers == 0)
+		return 0;
+
+	current_num = cvmx_read_csr(CVMX_FPA_QUEX_AVAILABLE(pool));
+	if (current_num) {
+		cvmx_dprintf("Fpa pool %d(%s) already has %llu buffers. "
+			     "Skipping setup.\n",
+		     pool, name, (unsigned long long)current_num);
+		return 0;
+	}
+
+	memory = cvmx_bootmem_alloc(buffer_size * buffers, align);
+	if (memory == NULL) {
+		cvmx_dprintf("Out of memory initializing fpa pool %d(%s).\n",
+			     pool, name);
+		return -1;
+	}
+	cvmx_fpa_setup_pool(pool, name, memory, buffer_size, buffers);
+	return 0;
+}
+
+/**
+ * Allocate memory and initialize the FPA pools using memory
+ * from cvmx-bootmem. Specifying zero for the number of
+ * buffers will cause that FPA pool to not be setup. This is
+ * useful if you aren't using some of the hardware and want
+ * to save memory. Use cvmx_helper_initialize_fpa instead of
+ * this function directly.
+ *
+ * @pip_pool: Should always be CVMX_FPA_PACKET_POOL
+ * @pip_size: Should always be CVMX_FPA_PACKET_POOL_SIZE
+ * @pip_buffers:
+ *                 Number of packet buffers.
+ * @wqe_pool: Should always be CVMX_FPA_WQE_POOL
+ * @wqe_size: Should always be CVMX_FPA_WQE_POOL_SIZE
+ * @wqe_entries:
+ *                 Number of work queue entries
+ * @pko_pool: Should always be CVMX_FPA_OUTPUT_BUFFER_POOL
+ * @pko_size: Should always be CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE
+ * @pko_buffers:
+ *                 PKO Command buffers. You should at minimum have two per
+ *                 each PKO queue.
+ * @tim_pool: Should always be CVMX_FPA_TIMER_POOL
+ * @tim_size: Should always be CVMX_FPA_TIMER_POOL_SIZE
+ * @tim_buffers:
+ *                 TIM ring buffer command queues. At least two per timer bucket
+ *                 is recommened.
+ * @dfa_pool: Should always be CVMX_FPA_DFA_POOL
+ * @dfa_size: Should always be CVMX_FPA_DFA_POOL_SIZE
+ * @dfa_buffers:
+ *                 DFA command buffer. A relatively small (32 for example)
+ *                 number should work.
+ * Returns Zero on success, non-zero if out of memory
+ */
+static int __cvmx_helper_initialize_fpa(int pip_pool, int pip_size,
+					int pip_buffers, int wqe_pool,
+					int wqe_size, int wqe_entries,
+					int pko_pool, int pko_size,
+					int pko_buffers, int tim_pool,
+					int tim_size, int tim_buffers,
+					int dfa_pool, int dfa_size,
+					int dfa_buffers)
+{
+	int status;
+
+	cvmx_fpa_enable();
+
+	if ((pip_buffers > 0) && (pip_buffers <= 64))
+		cvmx_dprintf
+		    ("Warning: %d packet buffers may not be enough for hardware"
+		     " prefetch. 65 or more is recommended.\n", pip_buffers);
+
+	if (pip_pool >= 0) {
+		status =
+		    __cvmx_helper_initialize_fpa_pool(pip_pool, pip_size,
+						      pip_buffers,
+						      "Packet Buffers");
+		if (status)
+			return status;
+	}
+
+	if (wqe_pool >= 0) {
+		status =
+		    __cvmx_helper_initialize_fpa_pool(wqe_pool, wqe_size,
+						      wqe_entries,
+						      "Work Queue Entries");
+		if (status)
+			return status;
+	}
+
+	if (pko_pool >= 0) {
+		status =
+		    __cvmx_helper_initialize_fpa_pool(pko_pool, pko_size,
+						      pko_buffers,
+						      "PKO Command Buffers");
+		if (status)
+			return status;
+	}
+
+	if (tim_pool >= 0) {
+		status =
+		    __cvmx_helper_initialize_fpa_pool(tim_pool, tim_size,
+						      tim_buffers,
+						      "TIM Command Buffers");
+		if (status)
+			return status;
+	}
+
+	if (dfa_pool >= 0) {
+		status =
+		    __cvmx_helper_initialize_fpa_pool(dfa_pool, dfa_size,
+						      dfa_buffers,
+						      "DFA Command Buffers");
+		if (status)
+			return status;
+	}
+
+	return 0;
+}
+
+/**
+ * Allocate memory and initialize the FPA pools using memory
+ * from cvmx-bootmem. Sizes of each element in the pools is
+ * controlled by the cvmx-config.h header file. Specifying
+ * zero for any parameter will cause that FPA pool to not be
+ * setup. This is useful if you aren't using some of the
+ * hardware and want to save memory.
+ *
+ * @packet_buffers:
+ *               Number of packet buffers to allocate
+ * @work_queue_entries:
+ *               Number of work queue entries
+ * @pko_buffers:
+ *               PKO Command buffers. You should at minimum have two per
+ *               each PKO queue.
+ * @tim_buffers:
+ *               TIM ring buffer command queues. At least two per timer bucket
+ *               is recommened.
+ * @dfa_buffers:
+ *               DFA command buffer. A relatively small (32 for example)
+ *               number should work.
+ * Returns Zero on success, non-zero if out of memory
+ */
+int cvmx_helper_initialize_fpa(int packet_buffers, int work_queue_entries,
+			       int pko_buffers, int tim_buffers,
+			       int dfa_buffers)
+{
+#ifndef CVMX_FPA_PACKET_POOL
+#define CVMX_FPA_PACKET_POOL -1
+#define CVMX_FPA_PACKET_POOL_SIZE 0
+#endif
+#ifndef CVMX_FPA_WQE_POOL
+#define CVMX_FPA_WQE_POOL -1
+#define CVMX_FPA_WQE_POOL_SIZE 0
+#endif
+#ifndef CVMX_FPA_OUTPUT_BUFFER_POOL
+#define CVMX_FPA_OUTPUT_BUFFER_POOL -1
+#define CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE 0
+#endif
+#ifndef CVMX_FPA_TIMER_POOL
+#define CVMX_FPA_TIMER_POOL -1
+#define CVMX_FPA_TIMER_POOL_SIZE 0
+#endif
+#ifndef CVMX_FPA_DFA_POOL
+#define CVMX_FPA_DFA_POOL -1
+#define CVMX_FPA_DFA_POOL_SIZE 0
+#endif
+	return __cvmx_helper_initialize_fpa(CVMX_FPA_PACKET_POOL,
+					    CVMX_FPA_PACKET_POOL_SIZE,
+					    packet_buffers, CVMX_FPA_WQE_POOL,
+					    CVMX_FPA_WQE_POOL_SIZE,
+					    work_queue_entries,
+					    CVMX_FPA_OUTPUT_BUFFER_POOL,
+					    CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE,
+					    pko_buffers, CVMX_FPA_TIMER_POOL,
+					    CVMX_FPA_TIMER_POOL_SIZE,
+					    tim_buffers, CVMX_FPA_DFA_POOL,
+					    CVMX_FPA_DFA_POOL_SIZE,
+					    dfa_buffers);
+}
diff -Naur linux-3.5.4/arch/mips/include/asm/irqflags.h linux-2012.09/arch/mips/include/asm/irqflags.h
--- linux-3.5.4/arch/mips/include/asm/irqflags.h	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/include/asm/irqflags.h	2012-10-27 16:24:02.000000000 +0800
@@ -16,66 +16,6 @@
 #include <linux/compiler.h>
 #include <asm/hazards.h>
 
-#if defined(__GENERATING_BOUNDS_H) || defined(__GENERATING_OFFSETS_S)
-#define __TI_PRE_COUNT (-1)
-#else
-#include <asm/asm-offsets.h>
-#define __TI_PRE_COUNT TI_PRE_COUNT
-#endif
-
-
-/*
- * Non-MIPS R2 processors executing functions such as arch_local_irq_disable()
- * are not preempt-safe: if preemption occurs between the mfc0 and the mtc0,
- * a stale status value may be stored.  To prevent this, we define
- * here arch_local_preempt_disable() and arch_local_preempt_enable(), which
- * are called before the mfc0 and after the mtc0, respectively.  A better
- * solution would "#include <linux/preempt.h> and use its declared routines,
- * but that is not viable due to numerous compile errors.
- *
- * MIPS R2 processors with the atomic interrupt enable/disable instructions
- * (EI/DI) do not have this issue.
- *
- * Doing this in C leads to even more uglyness due to include file hell.
- */
-
-static inline void arch_local_preempt_disable(void)
-{
-#if defined(CONFIG_PREEMPT) && !defined(CONFIG_CPU_MIPSR2)
-	__asm__ __volatile__(
-	"	.set	push						\n"
-	"	.set	noat						\n"
-	"	lw	$1, %[ti_pre_count]($28)			\n"
-	"	addi	$1, $1, 1					\n"
-	"	sw	$1, %[ti_pre_count]($28)			\n"
-	"	.set	pop						\n"
-	: /* no outputs */
-	: [ti_pre_count] "n" (__TI_PRE_COUNT)
-	: "memory");
-
-	barrier();
-#endif
-}
-
-static inline void arch_local_preempt_enable(void)
-{
-#if defined(CONFIG_PREEMPT) && !defined(CONFIG_CPU_MIPSR2)
-	__asm__ __volatile__(
-	"	.set	push						\n"
-	"	.set	noat						\n"
-	"	lw	$1, %[ti_pre_count]($28)			\n"
-	"	addi	$1, $1, -1					\n"
-	"	sw	$1, %[ti_pre_count]($28)			\n"
-	"	.set	pop						\n"
-	: /* no outputs */
-	: [ti_pre_count] "n" (__TI_PRE_COUNT)
-	: "memory");
-
-	barrier();
-#endif
-}
-
-
 __asm__(
 	"	.macro	arch_local_irq_enable				\n"
 	"	.set	push						\n"
@@ -159,15 +99,11 @@
 
 static inline void arch_local_irq_disable(void)
 {
-	arch_local_preempt_disable();
-
 	__asm__ __volatile__(
 		"arch_local_irq_disable"
 		: /* no outputs */
 		: /* no inputs */
 		: "memory");
-
-	arch_local_preempt_enable();
 }
 
 __asm__(
@@ -217,15 +153,10 @@
 static inline unsigned long arch_local_irq_save(void)
 {
 	unsigned long flags;
-
-	arch_local_preempt_disable();
-
 	asm volatile("arch_local_irq_save\t%0"
 		     : "=r" (flags)
 		     : /* no inputs */
 		     : "memory");
-
-	arch_local_preempt_enable();
 	return flags;
 }
 
@@ -283,30 +214,23 @@
 	if (unlikely(!(flags & 0x0400)))
 		smtc_ipi_replay();
 #endif
-	arch_local_preempt_disable();
 
 	__asm__ __volatile__(
 		"arch_local_irq_restore\t%0"
 		: "=r" (__tmp1)
 		: "0" (flags)
 		: "memory");
-
-	arch_local_preempt_enable();
 }
 
 static inline void __arch_local_irq_restore(unsigned long flags)
 {
 	unsigned long __tmp1;
 
-	arch_local_preempt_disable();
-
 	__asm__ __volatile__(
 		"arch_local_irq_restore\t%0"
 		: "=r" (__tmp1)
 		: "0" (flags)
 		: "memory");
-
-	arch_local_preempt_enable();
 }
 
 static inline int arch_irqs_disabled_flags(unsigned long flags)
diff -Naur linux-3.5.4/arch/mips/include/asm/mach-bcm63xx/bcm63xx_cpu.h linux-2012.09/arch/mips/include/asm/mach-bcm63xx/bcm63xx_cpu.h
--- linux-3.5.4/arch/mips/include/asm/mach-bcm63xx/bcm63xx_cpu.h	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/include/asm/mach-bcm63xx/bcm63xx_cpu.h	2012-10-27 16:24:01.000000000 +0800
@@ -102,6 +102,7 @@
 	RSET_UART1,
 	RSET_GPIO,
 	RSET_SPI,
+	RSET_SPI2,
 	RSET_UDC0,
 	RSET_OHCI0,
 	RSET_OHCI_PRIV,
@@ -134,10 +135,6 @@
 #define RSET_DSL_LMEM_SIZE		(64 * 1024 * 4)
 #define RSET_DSL_SIZE			4096
 #define RSET_WDT_SIZE			12
-#define BCM_6338_RSET_SPI_SIZE		64
-#define BCM_6348_RSET_SPI_SIZE		64
-#define BCM_6358_RSET_SPI_SIZE		1804
-#define BCM_6368_RSET_SPI_SIZE		1804
 #define RSET_ENET_SIZE			2048
 #define RSET_ENETDMA_SIZE		2048
 #define RSET_ENETSW_SIZE		65536
@@ -165,6 +162,7 @@
 #define BCM_6338_UART1_BASE		(0xdeadbeef)
 #define BCM_6338_GPIO_BASE		(0xfffe0400)
 #define BCM_6338_SPI_BASE		(0xfffe0c00)
+#define BCM_6338_SPI2_BASE		(0xdeadbeef)
 #define BCM_6338_UDC0_BASE		(0xdeadbeef)
 #define BCM_6338_USBDMA_BASE		(0xfffe2400)
 #define BCM_6338_OHCI0_BASE		(0xdeadbeef)
@@ -208,6 +206,7 @@
 #define BCM_6345_UART1_BASE		(0xdeadbeef)
 #define BCM_6345_GPIO_BASE		(0xfffe0400)
 #define BCM_6345_SPI_BASE		(0xdeadbeef)
+#define BCM_6345_SPI2_BASE		(0xdeadbeef)
 #define BCM_6345_UDC0_BASE		(0xdeadbeef)
 #define BCM_6345_USBDMA_BASE		(0xfffe2800)
 #define BCM_6345_ENET0_BASE		(0xfffe1800)
@@ -250,6 +249,7 @@
 #define BCM_6348_UART1_BASE		(0xdeadbeef)
 #define BCM_6348_GPIO_BASE		(0xfffe0400)
 #define BCM_6348_SPI_BASE		(0xfffe0c00)
+#define BCM_6348_SPI2_BASE		(0xdeadbeef)
 #define BCM_6348_UDC0_BASE		(0xfffe1000)
 #define BCM_6348_OHCI0_BASE		(0xfffe1b00)
 #define BCM_6348_OHCI_PRIV_BASE		(0xfffe1c00)
@@ -289,7 +289,8 @@
 #define BCM_6358_UART0_BASE		(0xfffe0100)
 #define BCM_6358_UART1_BASE		(0xfffe0120)
 #define BCM_6358_GPIO_BASE		(0xfffe0080)
-#define BCM_6358_SPI_BASE		(0xfffe0800)
+#define BCM_6358_SPI_BASE		(0xdeadbeef)
+#define BCM_6358_SPI2_BASE		(0xfffe0800)
 #define BCM_6358_UDC0_BASE		(0xfffe0800)
 #define BCM_6358_OHCI0_BASE		(0xfffe1400)
 #define BCM_6358_OHCI_PRIV_BASE		(0xdeadbeef)
@@ -330,7 +331,8 @@
 #define BCM_6368_UART0_BASE		(0xb0000100)
 #define BCM_6368_UART1_BASE		(0xb0000120)
 #define BCM_6368_GPIO_BASE		(0xb0000080)
-#define BCM_6368_SPI_BASE		(0xb0000800)
+#define BCM_6368_SPI_BASE		(0xdeadbeef)
+#define BCM_6368_SPI2_BASE		(0xb0000800)
 #define BCM_6368_UDC0_BASE		(0xdeadbeef)
 #define BCM_6368_OHCI0_BASE		(0xb0001600)
 #define BCM_6368_OHCI_PRIV_BASE		(0xdeadbeef)
@@ -377,6 +379,7 @@
 	__GEN_RSET_BASE(__cpu, UART1)					\
 	__GEN_RSET_BASE(__cpu, GPIO)					\
 	__GEN_RSET_BASE(__cpu, SPI)					\
+	__GEN_RSET_BASE(__cpu, SPI2)					\
 	__GEN_RSET_BASE(__cpu, UDC0)					\
 	__GEN_RSET_BASE(__cpu, OHCI0)					\
 	__GEN_RSET_BASE(__cpu, OHCI_PRIV)				\
@@ -415,6 +418,7 @@
 	[RSET_UART1]		= BCM_## __cpu ##_UART1_BASE,		\
 	[RSET_GPIO]		= BCM_## __cpu ##_GPIO_BASE,		\
 	[RSET_SPI]		= BCM_## __cpu ##_SPI_BASE,		\
+	[RSET_SPI2]		= BCM_## __cpu ##_SPI2_BASE,		\
 	[RSET_UDC0]		= BCM_## __cpu ##_UDC0_BASE,		\
 	[RSET_OHCI0]		= BCM_## __cpu ##_OHCI0_BASE,		\
 	[RSET_OHCI_PRIV]	= BCM_## __cpu ##_OHCI_PRIV_BASE,	\
@@ -474,7 +478,6 @@
  */
 enum bcm63xx_irq {
 	IRQ_TIMER = 0,
-	IRQ_SPI,
 	IRQ_UART0,
 	IRQ_UART1,
 	IRQ_DSL,
@@ -506,7 +509,6 @@
  * 6338 irqs
  */
 #define BCM_6338_TIMER_IRQ		(IRQ_INTERNAL_BASE + 0)
-#define BCM_6338_SPI_IRQ		(IRQ_INTERNAL_BASE + 1)
 #define BCM_6338_UART0_IRQ		(IRQ_INTERNAL_BASE + 2)
 #define BCM_6338_UART1_IRQ		0
 #define BCM_6338_DSL_IRQ		(IRQ_INTERNAL_BASE + 5)
@@ -537,7 +539,6 @@
  * 6345 irqs
  */
 #define BCM_6345_TIMER_IRQ		(IRQ_INTERNAL_BASE + 0)
-#define BCM_6345_SPI_IRQ		0
 #define BCM_6345_UART0_IRQ		(IRQ_INTERNAL_BASE + 2)
 #define BCM_6345_UART1_IRQ		0
 #define BCM_6345_DSL_IRQ		(IRQ_INTERNAL_BASE + 3)
@@ -568,7 +569,6 @@
  * 6348 irqs
  */
 #define BCM_6348_TIMER_IRQ		(IRQ_INTERNAL_BASE + 0)
-#define BCM_6348_SPI_IRQ		(IRQ_INTERNAL_BASE + 1)
 #define BCM_6348_UART0_IRQ		(IRQ_INTERNAL_BASE + 2)
 #define BCM_6348_UART1_IRQ		0
 #define BCM_6348_DSL_IRQ		(IRQ_INTERNAL_BASE + 4)
@@ -599,7 +599,6 @@
  * 6358 irqs
  */
 #define BCM_6358_TIMER_IRQ		(IRQ_INTERNAL_BASE + 0)
-#define BCM_6358_SPI_IRQ		(IRQ_INTERNAL_BASE + 1)
 #define BCM_6358_UART0_IRQ		(IRQ_INTERNAL_BASE + 2)
 #define BCM_6358_UART1_IRQ		(IRQ_INTERNAL_BASE + 3)
 #define BCM_6358_DSL_IRQ		(IRQ_INTERNAL_BASE + 29)
@@ -639,7 +638,6 @@
 #define BCM_6368_HIGH_IRQ_BASE		(IRQ_INTERNAL_BASE + 32)
 
 #define BCM_6368_TIMER_IRQ		(IRQ_INTERNAL_BASE + 0)
-#define BCM_6368_SPI_IRQ		(IRQ_INTERNAL_BASE + 1)
 #define BCM_6368_UART0_IRQ		(IRQ_INTERNAL_BASE + 2)
 #define BCM_6368_UART1_IRQ		(IRQ_INTERNAL_BASE + 3)
 #define BCM_6368_DSL_IRQ		(IRQ_INTERNAL_BASE + 4)
@@ -679,7 +677,6 @@
 
 #define __GEN_CPU_IRQ_TABLE(__cpu)					\
 	[IRQ_TIMER]		= BCM_## __cpu ##_TIMER_IRQ,		\
-	[IRQ_SPI]		= BCM_## __cpu ##_SPI_IRQ,		\
 	[IRQ_UART0]		= BCM_## __cpu ##_UART0_IRQ,		\
 	[IRQ_UART1]		= BCM_## __cpu ##_UART1_IRQ,		\
 	[IRQ_DSL]		= BCM_## __cpu ##_DSL_IRQ,		\
diff -Naur linux-3.5.4/arch/mips/include/asm/mach-bcm63xx/bcm63xx_dev_spi.h linux-2012.09/arch/mips/include/asm/mach-bcm63xx/bcm63xx_dev_spi.h
--- linux-3.5.4/arch/mips/include/asm/mach-bcm63xx/bcm63xx_dev_spi.h	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/include/asm/mach-bcm63xx/bcm63xx_dev_spi.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,89 +0,0 @@
-#ifndef BCM63XX_DEV_SPI_H
-#define BCM63XX_DEV_SPI_H
-
-#include <linux/types.h>
-#include <bcm63xx_io.h>
-#include <bcm63xx_regs.h>
-
-int __init bcm63xx_spi_register(void);
-
-struct bcm63xx_spi_pdata {
-	unsigned int	fifo_size;
-	int		bus_num;
-	int		num_chipselect;
-	u32		speed_hz;
-};
-
-enum bcm63xx_regs_spi {
-	SPI_CMD,
-	SPI_INT_STATUS,
-	SPI_INT_MASK_ST,
-	SPI_INT_MASK,
-	SPI_ST,
-	SPI_CLK_CFG,
-	SPI_FILL_BYTE,
-	SPI_MSG_TAIL,
-	SPI_RX_TAIL,
-	SPI_MSG_CTL,
-	SPI_MSG_DATA,
-	SPI_RX_DATA,
-};
-
-#define __GEN_SPI_RSET_BASE(__cpu, __rset)				\
-	case SPI_## __rset:						\
-		return SPI_## __cpu ##_## __rset;
-
-#define __GEN_SPI_RSET(__cpu)						\
-	switch (reg) {							\
-	__GEN_SPI_RSET_BASE(__cpu, CMD)					\
-	__GEN_SPI_RSET_BASE(__cpu, INT_STATUS)				\
-	__GEN_SPI_RSET_BASE(__cpu, INT_MASK_ST)				\
-	__GEN_SPI_RSET_BASE(__cpu, INT_MASK)				\
-	__GEN_SPI_RSET_BASE(__cpu, ST)					\
-	__GEN_SPI_RSET_BASE(__cpu, CLK_CFG)				\
-	__GEN_SPI_RSET_BASE(__cpu, FILL_BYTE)				\
-	__GEN_SPI_RSET_BASE(__cpu, MSG_TAIL)				\
-	__GEN_SPI_RSET_BASE(__cpu, RX_TAIL)				\
-	__GEN_SPI_RSET_BASE(__cpu, MSG_CTL)				\
-	__GEN_SPI_RSET_BASE(__cpu, MSG_DATA)				\
-	__GEN_SPI_RSET_BASE(__cpu, RX_DATA)				\
-	}
-
-#define __GEN_SPI_REGS_TABLE(__cpu)					\
-	[SPI_CMD]		= SPI_## __cpu ##_CMD,			\
-	[SPI_INT_STATUS]	= SPI_## __cpu ##_INT_STATUS,		\
-	[SPI_INT_MASK_ST]	= SPI_## __cpu ##_INT_MASK_ST,		\
-	[SPI_INT_MASK]		= SPI_## __cpu ##_INT_MASK,		\
-	[SPI_ST]		= SPI_## __cpu ##_ST,			\
-	[SPI_CLK_CFG]		= SPI_## __cpu ##_CLK_CFG,		\
-	[SPI_FILL_BYTE]		= SPI_## __cpu ##_FILL_BYTE,		\
-	[SPI_MSG_TAIL]		= SPI_## __cpu ##_MSG_TAIL,		\
-	[SPI_RX_TAIL]		= SPI_## __cpu ##_RX_TAIL,		\
-	[SPI_MSG_CTL]		= SPI_## __cpu ##_MSG_CTL,		\
-	[SPI_MSG_DATA]		= SPI_## __cpu ##_MSG_DATA,		\
-	[SPI_RX_DATA]		= SPI_## __cpu ##_RX_DATA,
-
-static inline unsigned long bcm63xx_spireg(enum bcm63xx_regs_spi reg)
-{
-#ifdef BCMCPU_RUNTIME_DETECT
-	extern const unsigned long *bcm63xx_regs_spi;
-
-	return bcm63xx_regs_spi[reg];
-#else
-#ifdef CONFIG_BCM63XX_CPU_6338
-	__GEN_SPI_RSET(6338)
-#endif
-#ifdef CONFIG_BCM63XX_CPU_6348
-	__GEN_SPI_RSET(6348)
-#endif
-#ifdef CONFIG_BCM63XX_CPU_6358
-	__GEN_SPI_RSET(6358)
-#endif
-#ifdef CONFIG_BCM63XX_CPU_6368
-	__GEN_SPI_RSET(6368)
-#endif
-#endif
-	return 0;
-}
-
-#endif /* BCM63XX_DEV_SPI_H */
diff -Naur linux-3.5.4/arch/mips/include/asm/mach-bcm63xx/bcm63xx_regs.h linux-2012.09/arch/mips/include/asm/mach-bcm63xx/bcm63xx_regs.h
--- linux-3.5.4/arch/mips/include/asm/mach-bcm63xx/bcm63xx_regs.h	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/include/asm/mach-bcm63xx/bcm63xx_regs.h	2012-10-27 16:24:01.000000000 +0800
@@ -90,29 +90,29 @@
 #define CKCTL_6368_PHYMIPS_EN		(1 << 6)
 #define CKCTL_6368_SWPKT_USB_EN		(1 << 7)
 #define CKCTL_6368_SWPKT_SAR_EN		(1 << 8)
-#define CKCTL_6368_SPI_EN		(1 << 9)
-#define CKCTL_6368_USBD_EN		(1 << 10)
-#define CKCTL_6368_SAR_EN		(1 << 11)
-#define CKCTL_6368_ROBOSW_EN		(1 << 12)
-#define CKCTL_6368_UTOPIA_EN		(1 << 13)
-#define CKCTL_6368_PCM_EN		(1 << 14)
-#define CKCTL_6368_USBH_EN		(1 << 15)
+#define CKCTL_6368_SPI_CLK_EN		(1 << 9)
+#define CKCTL_6368_USBD_CLK_EN		(1 << 10)
+#define CKCTL_6368_SAR_CLK_EN		(1 << 11)
+#define CKCTL_6368_ROBOSW_CLK_EN	(1 << 12)
+#define CKCTL_6368_UTOPIA_CLK_EN	(1 << 13)
+#define CKCTL_6368_PCM_CLK_EN		(1 << 14)
+#define CKCTL_6368_USBH_CLK_EN		(1 << 15)
 #define CKCTL_6368_DISABLE_GLESS_EN	(1 << 16)
-#define CKCTL_6368_NAND_EN		(1 << 17)
-#define CKCTL_6368_IPSEC_EN		(1 << 18)
+#define CKCTL_6368_NAND_CLK_EN		(1 << 17)
+#define CKCTL_6368_IPSEC_CLK_EN		(1 << 18)
 
 #define CKCTL_6368_ALL_SAFE_EN		(CKCTL_6368_SWPKT_USB_EN |	\
 					CKCTL_6368_SWPKT_SAR_EN |	\
-					CKCTL_6368_SPI_EN |		\
-					CKCTL_6368_USBD_EN |		\
-					CKCTL_6368_SAR_EN |		\
-					CKCTL_6368_ROBOSW_EN |		\
-					CKCTL_6368_UTOPIA_EN |		\
-					CKCTL_6368_PCM_EN |		\
-					CKCTL_6368_USBH_EN |		\
+					CKCTL_6368_SPI_CLK_EN |		\
+					CKCTL_6368_USBD_CLK_EN |	\
+					CKCTL_6368_SAR_CLK_EN |		\
+					CKCTL_6368_ROBOSW_CLK_EN |	\
+					CKCTL_6368_UTOPIA_CLK_EN |	\
+					CKCTL_6368_PCM_CLK_EN |		\
+					CKCTL_6368_USBH_CLK_EN |	\
 					CKCTL_6368_DISABLE_GLESS_EN |	\
-					CKCTL_6368_NAND_EN |		\
-					CKCTL_6368_IPSEC_EN)
+					CKCTL_6368_NAND_CLK_EN |	\
+					CKCTL_6368_IPSEC_CLK_EN)
 
 /* System PLL Control register  */
 #define PERF_SYS_PLL_CTL_REG		0x8
@@ -973,123 +973,4 @@
 #define M2M_SRCID_REG(x)		((x) * 0x40 + 0x14)
 #define M2M_DSTID_REG(x)		((x) * 0x40 + 0x18)
 
-/*************************************************************************
- * _REG relative to RSET_SPI
- *************************************************************************/
-
-/* BCM 6338 SPI core */
-#define SPI_6338_CMD			0x00	/* 16-bits register */
-#define SPI_6338_INT_STATUS		0x02
-#define SPI_6338_INT_MASK_ST		0x03
-#define SPI_6338_INT_MASK		0x04
-#define SPI_6338_ST			0x05
-#define SPI_6338_CLK_CFG		0x06
-#define SPI_6338_FILL_BYTE		0x07
-#define SPI_6338_MSG_TAIL		0x09
-#define SPI_6338_RX_TAIL		0x0b
-#define SPI_6338_MSG_CTL		0x40
-#define SPI_6338_MSG_DATA		0x41
-#define SPI_6338_MSG_DATA_SIZE		0x3f
-#define SPI_6338_RX_DATA		0x80
-#define SPI_6338_RX_DATA_SIZE		0x3f
-
-/* BCM 6348 SPI core */
-#define SPI_6348_CMD			0x00	/* 16-bits register */
-#define SPI_6348_INT_STATUS		0x02
-#define SPI_6348_INT_MASK_ST		0x03
-#define SPI_6348_INT_MASK		0x04
-#define SPI_6348_ST			0x05
-#define SPI_6348_CLK_CFG		0x06
-#define SPI_6348_FILL_BYTE		0x07
-#define SPI_6348_MSG_TAIL		0x09
-#define SPI_6348_RX_TAIL		0x0b
-#define SPI_6348_MSG_CTL		0x40
-#define SPI_6348_MSG_DATA		0x41
-#define SPI_6348_MSG_DATA_SIZE		0x3f
-#define SPI_6348_RX_DATA		0x80
-#define SPI_6348_RX_DATA_SIZE		0x3f
-
-/* BCM 6358 SPI core */
-#define SPI_6358_MSG_CTL		0x00	/* 16-bits register */
-#define SPI_6358_MSG_DATA		0x02
-#define SPI_6358_MSG_DATA_SIZE		0x21e
-#define SPI_6358_RX_DATA		0x400
-#define SPI_6358_RX_DATA_SIZE		0x220
-#define SPI_6358_CMD			0x700	/* 16-bits register */
-#define SPI_6358_INT_STATUS		0x702
-#define SPI_6358_INT_MASK_ST		0x703
-#define SPI_6358_INT_MASK		0x704
-#define SPI_6358_ST			0x705
-#define SPI_6358_CLK_CFG		0x706
-#define SPI_6358_FILL_BYTE		0x707
-#define SPI_6358_MSG_TAIL		0x709
-#define SPI_6358_RX_TAIL		0x70B
-
-/* BCM 6358 SPI core */
-#define SPI_6368_MSG_CTL		0x00	/* 16-bits register */
-#define SPI_6368_MSG_DATA		0x02
-#define SPI_6368_MSG_DATA_SIZE		0x21e
-#define SPI_6368_RX_DATA		0x400
-#define SPI_6368_RX_DATA_SIZE		0x220
-#define SPI_6368_CMD			0x700	/* 16-bits register */
-#define SPI_6368_INT_STATUS		0x702
-#define SPI_6368_INT_MASK_ST		0x703
-#define SPI_6368_INT_MASK		0x704
-#define SPI_6368_ST			0x705
-#define SPI_6368_CLK_CFG		0x706
-#define SPI_6368_FILL_BYTE		0x707
-#define SPI_6368_MSG_TAIL		0x709
-#define SPI_6368_RX_TAIL		0x70B
-
-/* Shared SPI definitions */
-
-/* Message configuration */
-#define SPI_FD_RW			0x00
-#define SPI_HD_W			0x01
-#define SPI_HD_R			0x02
-#define SPI_BYTE_CNT_SHIFT		0
-#define SPI_MSG_TYPE_SHIFT		14
-
-/* Command */
-#define SPI_CMD_NOOP			0x00
-#define SPI_CMD_SOFT_RESET		0x01
-#define SPI_CMD_HARD_RESET		0x02
-#define SPI_CMD_START_IMMEDIATE		0x03
-#define SPI_CMD_COMMAND_SHIFT		0
-#define SPI_CMD_COMMAND_MASK		0x000f
-#define SPI_CMD_DEVICE_ID_SHIFT		4
-#define SPI_CMD_PREPEND_BYTE_CNT_SHIFT	8
-#define SPI_CMD_ONE_BYTE_SHIFT		11
-#define SPI_CMD_ONE_WIRE_SHIFT		12
-#define SPI_DEV_ID_0			0
-#define SPI_DEV_ID_1			1
-#define SPI_DEV_ID_2			2
-#define SPI_DEV_ID_3			3
-
-/* Interrupt mask */
-#define SPI_INTR_CMD_DONE		0x01
-#define SPI_INTR_RX_OVERFLOW		0x02
-#define SPI_INTR_TX_UNDERFLOW		0x04
-#define SPI_INTR_TX_OVERFLOW		0x08
-#define SPI_INTR_RX_UNDERFLOW		0x10
-#define SPI_INTR_CLEAR_ALL		0x1f
-
-/* Status */
-#define SPI_RX_EMPTY			0x02
-#define SPI_CMD_BUSY			0x04
-#define SPI_SERIAL_BUSY			0x08
-
-/* Clock configuration */
-#define SPI_CLK_20MHZ			0x00
-#define SPI_CLK_0_391MHZ		0x01
-#define SPI_CLK_0_781MHZ		0x02 /* default */
-#define SPI_CLK_1_563MHZ		0x03
-#define SPI_CLK_3_125MHZ		0x04
-#define SPI_CLK_6_250MHZ		0x05
-#define SPI_CLK_12_50MHZ		0x06
-#define SPI_CLK_MASK			0x07
-#define SPI_SSOFFTIME_MASK		0x38
-#define SPI_SSOFFTIME_SHIFT		3
-#define SPI_BYTE_SWAP			0x80
-
 #endif /* BCM63XX_REGS_H_ */
diff -Naur linux-3.5.4/arch/mips/include/asm/module.h linux-2012.09/arch/mips/include/asm/module.h
--- linux-3.5.4/arch/mips/include/asm/module.h	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/include/asm/module.h	2012-10-27 16:24:02.000000000 +0800
@@ -10,7 +10,6 @@
 	struct list_head dbe_list;
 	const struct exception_table_entry *dbe_start;
 	const struct exception_table_entry *dbe_end;
-	struct mips_hi16 *r_mips_hi16_list;
 };
 
 typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
diff -Naur linux-3.5.4/arch/mips/include/asm/octeon/cvmx-helper-fpa.h linux-2012.09/arch/mips/include/asm/octeon/cvmx-helper-fpa.h
--- linux-3.5.4/arch/mips/include/asm/octeon/cvmx-helper-fpa.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2012.09/arch/mips/include/asm/octeon/cvmx-helper-fpa.h	2012-10-27 16:24:01.000000000 +0800
@@ -0,0 +1,64 @@
+/***********************license start***************
+ * Author: Cavium Networks
+ *
+ * Contact: support@caviumnetworks.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2003-2008 Cavium Networks
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Networks for more information
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Helper functions for FPA setup.
+ *
+ */
+#ifndef __CVMX_HELPER_H_FPA__
+#define __CVMX_HELPER_H_FPA__
+
+/**
+ * Allocate memory and initialize the FPA pools using memory
+ * from cvmx-bootmem. Sizes of each element in the pools is
+ * controlled by the cvmx-config.h header file. Specifying
+ * zero for any parameter will cause that FPA pool to not be
+ * setup. This is useful if you aren't using some of the
+ * hardware and want to save memory.
+ *
+ * @packet_buffers:
+ *               Number of packet buffers to allocate
+ * @work_queue_entries:
+ *               Number of work queue entries
+ * @pko_buffers:
+ *               PKO Command buffers. You should at minimum have two per
+ *               each PKO queue.
+ * @tim_buffers:
+ *               TIM ring buffer command queues. At least two per timer bucket
+ *               is recommened.
+ * @dfa_buffers:
+ *               DFA command buffer. A relatively small (32 for example)
+ *               number should work.
+ * Returns Zero on success, non-zero if out of memory
+ */
+extern int cvmx_helper_initialize_fpa(int packet_buffers,
+				      int work_queue_entries, int pko_buffers,
+				      int tim_buffers, int dfa_buffers);
+
+#endif /* __CVMX_HELPER_H__ */
diff -Naur linux-3.5.4/arch/mips/include/asm/octeon/cvmx-helper.h linux-2012.09/arch/mips/include/asm/octeon/cvmx-helper.h
--- linux-3.5.4/arch/mips/include/asm/octeon/cvmx-helper.h	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/include/asm/octeon/cvmx-helper.h	2012-10-27 16:24:01.000000000 +0800
@@ -61,6 +61,8 @@
 	} s;
 } cvmx_helper_link_info_t;
 
+#include "cvmx-helper-fpa.h"
+
 #include <asm/octeon/cvmx-helper-errata.h>
 #include "cvmx-helper-loop.h"
 #include "cvmx-helper-npi.h"
diff -Naur linux-3.5.4/arch/mips/include/asm/smvp.h linux-2012.09/arch/mips/include/asm/smvp.h
--- linux-3.5.4/arch/mips/include/asm/smvp.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2012.09/arch/mips/include/asm/smvp.h	2012-10-27 16:24:02.000000000 +0800
@@ -0,0 +1,19 @@
+#ifndef _ASM_SMVP_H
+#define _ASM_SMVP_H
+
+/*
+ * Definitions for SMVP multitasking on MIPS MT cores
+ */
+struct task_struct;
+
+extern void smvp_smp_setup(void);
+extern void smvp_smp_finish(void);
+extern void smvp_boot_secondary(int cpu, struct task_struct *t);
+extern void smvp_init_secondary(void);
+extern void smvp_smp_finish(void);
+extern void smvp_cpus_done(void);
+extern void smvp_prepare_cpus(unsigned int max_cpus);
+
+/* This is platform specific */
+extern void smvp_send_ipi(int cpu, unsigned int action);
+#endif /*  _ASM_SMVP_H */
diff -Naur linux-3.5.4/arch/mips/include/asm/uasm.h linux-2012.09/arch/mips/include/asm/uasm.h
--- linux-3.5.4/arch/mips/include/asm/uasm.h	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/include/asm/uasm.h	2012-10-27 16:24:02.000000000 +0800
@@ -6,7 +6,6 @@
  * Copyright (C) 2004, 2005, 2006, 2008  Thiemo Seufer
  * Copyright (C) 2005  Maciej W. Rozycki
  * Copyright (C) 2006  Ralf Baechle (ralf@linux-mips.org)
- * Copyright (C) 2012  MIPS Technologies, Inc.
  */
 
 #include <linux/types.h>
@@ -63,12 +62,8 @@
 
 Ip_u2u1s3(_addiu);
 Ip_u3u1u2(_addu);
-Ip_u3u1u2(_and);
 Ip_u2u1u3(_andi);
-Ip_u1u2s3(_bbit0);
-Ip_u1u2s3(_bbit0);
-Ip_u1u2s3(_bbit1);
-Ip_u1u2s3(_bbit1);
+Ip_u3u1u2(_and);
 Ip_u1u2s3(_beq);
 Ip_u1u2s3(_beql);
 Ip_u1s2(_bgez);
@@ -77,54 +72,55 @@
 Ip_u1s2(_bltzl);
 Ip_u1u2s3(_bne);
 Ip_u2s3u1(_cache);
-Ip_u2u1s3(_daddiu);
-Ip_u3u1u2(_daddu);
-Ip_u2u1msbu3(_dins);
-Ip_u2u1msbu3(_dinsm);
 Ip_u1u2u3(_dmfc0);
 Ip_u1u2u3(_dmtc0);
-Ip_u2u1u3(_drotr);
-Ip_u2u1u3(_drotr32);
+Ip_u2u1s3(_daddiu);
+Ip_u3u1u2(_daddu);
 Ip_u2u1u3(_dsll);
 Ip_u2u1u3(_dsll32);
 Ip_u2u1u3(_dsra);
 Ip_u2u1u3(_dsrl);
 Ip_u2u1u3(_dsrl32);
+Ip_u2u1u3(_drotr);
+Ip_u2u1u3(_drotr32);
 Ip_u3u1u2(_dsubu);
 Ip_0(_eret);
 Ip_u1(_j);
 Ip_u1(_jal);
 Ip_u1(_jr);
 Ip_u2s3u1(_ld);
-Ip_u3u1u2(_ldx);
 Ip_u2s3u1(_ll);
 Ip_u2s3u1(_lld);
 Ip_u1s2(_lui);
 Ip_u2s3u1(_lw);
-Ip_u3u1u2(_lwx);
 Ip_u1u2u3(_mfc0);
 Ip_u1u2u3(_mtc0);
-Ip_u3u1u2(_or);
 Ip_u2u1u3(_ori);
+Ip_u3u1u2(_or);
 Ip_u2s3u1(_pref);
 Ip_0(_rfe);
-Ip_u2u1u3(_rotr);
 Ip_u2s3u1(_sc);
 Ip_u2s3u1(_scd);
 Ip_u2s3u1(_sd);
 Ip_u2u1u3(_sll);
 Ip_u2u1u3(_sra);
 Ip_u2u1u3(_srl);
+Ip_u2u1u3(_rotr);
 Ip_u3u1u2(_subu);
 Ip_u2s3u1(_sw);
-Ip_u1(_syscall);
 Ip_0(_tlbp);
 Ip_0(_tlbr);
 Ip_0(_tlbwi);
 Ip_0(_tlbwr);
 Ip_u3u1u2(_xor);
 Ip_u2u1u3(_xori);
-
+Ip_u2u1msbu3(_dins);
+Ip_u2u1msbu3(_dinsm);
+Ip_u1(_syscall);
+Ip_u1u2s3(_bbit0);
+Ip_u1u2s3(_bbit1);
+Ip_u3u1u2(_lwx);
+Ip_u3u1u2(_ldx);
 
 /* Handle labels. */
 struct uasm_label {
@@ -149,37 +145,37 @@
 
 /* convenience macros for instructions */
 #ifdef CONFIG_64BIT
-# define UASM_i_ADDIU(buf, rs, rt, val) uasm_i_daddiu(buf, rs, rt, val)
-# define UASM_i_ADDU(buf, rs, rt, rd) uasm_i_daddu(buf, rs, rt, rd)
-# define UASM_i_LL(buf, rs, rt, off) uasm_i_lld(buf, rs, rt, off)
 # define UASM_i_LW(buf, rs, rt, off) uasm_i_ld(buf, rs, rt, off)
-# define UASM_i_LWX(buf, rs, rt, rd) uasm_i_ldx(buf, rs, rt, rd)
-# define UASM_i_MFC0(buf, rt, rd...) uasm_i_dmfc0(buf, rt, rd)
-# define UASM_i_MTC0(buf, rt, rd...) uasm_i_dmtc0(buf, rt, rd)
-# define UASM_i_ROTR(buf, rs, rt, sh) uasm_i_drotr(buf, rs, rt, sh)
-# define UASM_i_SC(buf, rs, rt, off) uasm_i_scd(buf, rs, rt, off)
+# define UASM_i_SW(buf, rs, rt, off) uasm_i_sd(buf, rs, rt, off)
 # define UASM_i_SLL(buf, rs, rt, sh) uasm_i_dsll(buf, rs, rt, sh)
 # define UASM_i_SRA(buf, rs, rt, sh) uasm_i_dsra(buf, rs, rt, sh)
 # define UASM_i_SRL(buf, rs, rt, sh) uasm_i_dsrl(buf, rs, rt, sh)
 # define UASM_i_SRL_SAFE(buf, rs, rt, sh) uasm_i_dsrl_safe(buf, rs, rt, sh)
+# define UASM_i_ROTR(buf, rs, rt, sh) uasm_i_drotr(buf, rs, rt, sh)
+# define UASM_i_MFC0(buf, rt, rd...) uasm_i_dmfc0(buf, rt, rd)
+# define UASM_i_MTC0(buf, rt, rd...) uasm_i_dmtc0(buf, rt, rd)
+# define UASM_i_ADDIU(buf, rs, rt, val) uasm_i_daddiu(buf, rs, rt, val)
+# define UASM_i_ADDU(buf, rs, rt, rd) uasm_i_daddu(buf, rs, rt, rd)
 # define UASM_i_SUBU(buf, rs, rt, rd) uasm_i_dsubu(buf, rs, rt, rd)
-# define UASM_i_SW(buf, rs, rt, off) uasm_i_sd(buf, rs, rt, off)
+# define UASM_i_LL(buf, rs, rt, off) uasm_i_lld(buf, rs, rt, off)
+# define UASM_i_SC(buf, rs, rt, off) uasm_i_scd(buf, rs, rt, off)
+# define UASM_i_LWX(buf, rs, rt, rd) uasm_i_ldx(buf, rs, rt, rd)
 #else
-# define UASM_i_ADDIU(buf, rs, rt, val) uasm_i_addiu(buf, rs, rt, val)
-# define UASM_i_ADDU(buf, rs, rt, rd) uasm_i_addu(buf, rs, rt, rd)
-# define UASM_i_LL(buf, rs, rt, off) uasm_i_ll(buf, rs, rt, off)
 # define UASM_i_LW(buf, rs, rt, off) uasm_i_lw(buf, rs, rt, off)
-# define UASM_i_LWX(buf, rs, rt, rd) uasm_i_lwx(buf, rs, rt, rd)
-# define UASM_i_MFC0(buf, rt, rd...) uasm_i_mfc0(buf, rt, rd)
-# define UASM_i_MTC0(buf, rt, rd...) uasm_i_mtc0(buf, rt, rd)
-# define UASM_i_ROTR(buf, rs, rt, sh) uasm_i_rotr(buf, rs, rt, sh)
-# define UASM_i_SC(buf, rs, rt, off) uasm_i_sc(buf, rs, rt, off)
+# define UASM_i_SW(buf, rs, rt, off) uasm_i_sw(buf, rs, rt, off)
 # define UASM_i_SLL(buf, rs, rt, sh) uasm_i_sll(buf, rs, rt, sh)
 # define UASM_i_SRA(buf, rs, rt, sh) uasm_i_sra(buf, rs, rt, sh)
 # define UASM_i_SRL(buf, rs, rt, sh) uasm_i_srl(buf, rs, rt, sh)
 # define UASM_i_SRL_SAFE(buf, rs, rt, sh) uasm_i_srl(buf, rs, rt, sh)
+# define UASM_i_ROTR(buf, rs, rt, sh) uasm_i_rotr(buf, rs, rt, sh)
+# define UASM_i_MFC0(buf, rt, rd...) uasm_i_mfc0(buf, rt, rd)
+# define UASM_i_MTC0(buf, rt, rd...) uasm_i_mtc0(buf, rt, rd)
+# define UASM_i_ADDIU(buf, rs, rt, val) uasm_i_addiu(buf, rs, rt, val)
+# define UASM_i_ADDU(buf, rs, rt, rd) uasm_i_addu(buf, rs, rt, rd)
 # define UASM_i_SUBU(buf, rs, rt, rd) uasm_i_subu(buf, rs, rt, rd)
-# define UASM_i_SW(buf, rs, rt, off) uasm_i_sw(buf, rs, rt, off)
+# define UASM_i_LL(buf, rs, rt, off) uasm_i_ll(buf, rs, rt, off)
+# define UASM_i_SC(buf, rs, rt, off) uasm_i_sc(buf, rs, rt, off)
+# define UASM_i_LWX(buf, rs, rt, rd) uasm_i_lwx(buf, rs, rt, rd)
 #endif
 
 #define uasm_i_b(buf, off) uasm_i_beq(buf, 0, 0, off)
@@ -187,10 +183,19 @@
 #define uasm_i_beqzl(buf, rs, off) uasm_i_beql(buf, rs, 0, off)
 #define uasm_i_bnez(buf, rs, off) uasm_i_bne(buf, rs, 0, off)
 #define uasm_i_bnezl(buf, rs, off) uasm_i_bnel(buf, rs, 0, off)
-#define uasm_i_ehb(buf) uasm_i_sll(buf, 0, 0, 3)
 #define uasm_i_move(buf, a, b) UASM_i_ADDU(buf, a, 0, b)
 #define uasm_i_nop(buf) uasm_i_sll(buf, 0, 0, 0)
 #define uasm_i_ssnop(buf) uasm_i_sll(buf, 0, 0, 1)
+#define uasm_i_ehb(buf) uasm_i_sll(buf, 0, 0, 3)
+
+static inline void uasm_i_dsrl_safe(u32 **p, unsigned int a1,
+				    unsigned int a2, unsigned int a3)
+{
+	if (a3 < 32)
+		uasm_i_dsrl(p, a1, a2, a3);
+	else
+		uasm_i_dsrl32(p, a1, a2, a3 - 32);
+}
 
 static inline void uasm_i_drotr_safe(u32 **p, unsigned int a1,
 				     unsigned int a2, unsigned int a3)
@@ -210,15 +215,6 @@
 		uasm_i_dsll32(p, a1, a2, a3 - 32);
 }
 
-static inline void uasm_i_dsrl_safe(u32 **p, unsigned int a1,
-				    unsigned int a2, unsigned int a3)
-{
-	if (a3 < 32)
-		uasm_i_dsrl(p, a1, a2, a3);
-	else
-		uasm_i_dsrl32(p, a1, a2, a3 - 32);
-}
-
 /* Handle relocations. */
 struct uasm_reloc {
 	u32 *addr;
@@ -238,16 +234,16 @@
 int uasm_insn_has_bdelay(struct uasm_reloc *rel, u32 *addr);
 
 /* Convenience functions for labeled branches. */
+void uasm_il_bltz(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
 void uasm_il_b(u32 **p, struct uasm_reloc **r, int lid);
-void uasm_il_bbit0(u32 **p, struct uasm_reloc **r, unsigned int reg,
-		   unsigned int bit, int lid);
-void uasm_il_bbit1(u32 **p, struct uasm_reloc **r, unsigned int reg,
-		   unsigned int bit, int lid);
 void uasm_il_beqz(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
 void uasm_il_beqzl(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
-void uasm_il_bgezl(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
-void uasm_il_bgez(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
-void uasm_il_bltz(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
 void uasm_il_bne(u32 **p, struct uasm_reloc **r, unsigned int reg1,
 		 unsigned int reg2, int lid);
 void uasm_il_bnez(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
+void uasm_il_bgezl(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
+void uasm_il_bgez(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
+void uasm_il_bbit0(u32 **p, struct uasm_reloc **r, unsigned int reg,
+		   unsigned int bit, int lid);
+void uasm_il_bbit1(u32 **p, struct uasm_reloc **r, unsigned int reg,
+		   unsigned int bit, int lid);
diff -Naur linux-3.5.4/arch/mips/Kconfig linux-2012.09/arch/mips/Kconfig
--- linux-3.5.4/arch/mips/Kconfig	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/Kconfig	2012-10-27 16:24:02.000000000 +0800
@@ -1432,7 +1432,6 @@
 	select WEAK_ORDERING
 	select CPU_SUPPORTS_HIGHMEM
 	select CPU_SUPPORTS_HUGEPAGES
-	select ARCH_SPARSEMEM_ENABLE
 	help
 	  The Cavium Octeon processor is a highly integrated chip containing
 	  many ethernet hardware widgets for networking tasks. The processor
diff -Naur linux-3.5.4/arch/mips/kernel/asm-offsets.c linux-2012.09/arch/mips/kernel/asm-offsets.c
--- linux-3.5.4/arch/mips/kernel/asm-offsets.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/kernel/asm-offsets.c	2012-10-27 16:24:00.000000000 +0800
@@ -8,7 +8,6 @@
  * Kevin Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com
  * Copyright (C) 2000 MIPS Technologies, Inc.
  */
-#define __GENERATING_OFFSETS_S
 #include <linux/compat.h>
 #include <linux/types.h>
 #include <linux/sched.h>
diff -Naur linux-3.5.4/arch/mips/kernel/cpu-probe.c linux-2012.09/arch/mips/kernel/cpu-probe.c
--- linux-3.5.4/arch/mips/kernel/cpu-probe.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/kernel/cpu-probe.c	2012-10-27 16:24:00.000000000 +0800
@@ -355,6 +355,7 @@
 				c->cputype = CPU_R3000A;
 				__cpu_name[cpu] = "R3000A";
 			}
+			break;
 		} else {
 			c->cputype = CPU_R3000;
 			__cpu_name[cpu] = "R3000";
diff -Naur linux-3.5.4/arch/mips/kernel/module.c linux-2012.09/arch/mips/kernel/module.c
--- linux-3.5.4/arch/mips/kernel/module.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/kernel/module.c	2012-10-27 16:24:00.000000000 +0800
@@ -39,6 +39,8 @@
 	Elf_Addr value;
 };
 
+static struct mips_hi16 *mips_hi16_list;
+
 static LIST_HEAD(dbe_list);
 static DEFINE_SPINLOCK(dbe_lock);
 
@@ -126,8 +128,8 @@
 
 	n->addr = (Elf_Addr *)location;
 	n->value = v;
-	n->next = me->arch.r_mips_hi16_list;
-	me->arch.r_mips_hi16_list = n;
+	n->next = mips_hi16_list;
+	mips_hi16_list = n;
 
 	return 0;
 }
@@ -140,28 +142,18 @@
 	return 0;
 }
 
-static void free_relocation_chain(struct mips_hi16 *l)
-{
-	struct mips_hi16 *next;
-
-	while (l) {
-		next = l->next;
-		kfree(l);
-		l = next;
-	}
-}
-
 static int apply_r_mips_lo16_rel(struct module *me, u32 *location, Elf_Addr v)
 {
 	unsigned long insnlo = *location;
-	struct mips_hi16 *l;
 	Elf_Addr val, vallo;
 
 	/* Sign extend the addend we extract from the lo insn.  */
 	vallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;
 
-	if (me->arch.r_mips_hi16_list != NULL) {
-		l = me->arch.r_mips_hi16_list;
+	if (mips_hi16_list != NULL) {
+		struct mips_hi16 *l;
+
+		l = mips_hi16_list;
 		while (l != NULL) {
 			struct mips_hi16 *next;
 			unsigned long insn;
@@ -196,7 +188,7 @@
 			l = next;
 		}
 
-		me->arch.r_mips_hi16_list = NULL;
+		mips_hi16_list = NULL;
 	}
 
 	/*
@@ -209,9 +201,6 @@
 	return 0;
 
 out_danger:
-	free_relocation_chain(l);
-	me->arch.r_mips_hi16_list = NULL;
-
 	pr_err("module %s: dangerous R_MIPS_LO16 REL relocation\n", me->name);
 
 	return -ENOEXEC;
@@ -284,7 +273,6 @@
 	pr_debug("Applying relocate section %u to %u\n", relsec,
 	       sechdrs[relsec].sh_info);
 
-	me->arch.r_mips_hi16_list = NULL;
 	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
 		/* This is where to make the change */
 		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
@@ -308,19 +296,6 @@
 			return res;
 	}
 
-	/*
-	 * Normally the hi16 list should be deallocated at this point.  A
-	 * malformed binary however could contain a series of R_MIPS_HI16
-	 * relocations not followed by a R_MIPS_LO16 relocation.  In that
-	 * case, free up the list and return an error.
-	 */
-	if (me->arch.r_mips_hi16_list) {
-		free_relocation_chain(me->arch.r_mips_hi16_list);
-		me->arch.r_mips_hi16_list = NULL;
-
-		return -ENOEXEC;
-	}
-
 	return 0;
 }
 
diff -Naur linux-3.5.4/arch/mips/kernel/smp-cmp.c linux-2012.09/arch/mips/kernel/smp-cmp.c
--- linux-3.5.4/arch/mips/kernel/smp-cmp.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/kernel/smp-cmp.c	2012-10-27 16:24:00.000000000 +0800
@@ -102,7 +102,7 @@
 	c->vpe_id = (read_c0_tcbind() >> TCBIND_CURVPE_SHIFT) & TCBIND_CURVPE;
 #endif
 #ifdef CONFIG_MIPS_MT_SMTC
-	c->tc_id  = (read_c0_tcbind() & TCBIND_CURTC) >> TCBIND_CURTC_SHIFT;
+	c->tc_id  = (read_c0_tcbind() >> TCBIND_CURTC_SHIFT) & TCBIND_CURTC;
 #endif
 }
 
diff -Naur linux-3.5.4/arch/mips/kernel/traps.c linux-2012.09/arch/mips/kernel/traps.c
--- linux-3.5.4/arch/mips/kernel/traps.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/kernel/traps.c	2012-10-27 16:24:00.000000000 +0800
@@ -1021,24 +1021,6 @@
 
 		return;
 
-	case 3:
-		/*
-		 * Old (MIPS I and MIPS II) processors will set this code
-		 * for COP1X opcode instructions that replaced the original
-		 * COP3 space.  We don't limit COP1 space instructions in
-		 * the emulator according to the CPU ISA, so we want to
-		 * treat COP1X instructions consistently regardless of which
-		 * code the CPU chose.  Therefore we redirect this trap to
-		 * the FP emulator too.
-		 *
-		 * Then some newer FPU-less processors use this code
-		 * erroneously too, so they are covered by this choice
-		 * as well.
-		 */
-		if (raw_cpu_has_fpu)
-			break;
-		/* Fall through.  */
-
 	case 1:
 		if (used_math())	/* Using the FPU again.  */
 			own_fpu(1);
@@ -1062,6 +1044,9 @@
 	case 2:
 		raw_notifier_call_chain(&cu2_chain, CU2_EXCEPTION, regs);
 		return;
+
+	case 3:
+		break;
 	}
 
 	force_sig(SIGILL, current);
diff -Naur linux-3.5.4/arch/mips/math-emu/cp1emu.c linux-2012.09/arch/mips/math-emu/cp1emu.c
--- linux-3.5.4/arch/mips/math-emu/cp1emu.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/math-emu/cp1emu.c	2012-10-27 16:24:02.000000000 +0800
@@ -171,17 +171,16 @@
  * In the Linux kernel, we support selection of FPR format on the
  * basis of the Status.FR bit.  If an FPU is not present, the FR bit
  * is hardwired to zero, which would imply a 32-bit FPU even for
- * 64-bit CPUs so we rather look at TIF_32BIT_REGS.
- * FPU emu is slow and bulky and optimizing this function offers fairly
- * sizeable benefits so we try to be clever and make this function return
- * a constant whenever possible, that is on 64-bit kernels without O32
- * compatibility enabled and on 32-bit kernels.
+ * 64-bit CPUs.  For 64-bit kernels with no FPU we use TIF_32BIT_REGS
+ * as a proxy for the FR bit so that a 64-bit FPU is emulated.  In any
+ * case, for a 32-bit kernel which uses the O32 MIPS ABI, only the
+ * even FPRs are used (Status.FR = 0).
  */
 static inline int cop1_64bit(struct pt_regs *xcp)
 {
-#if defined(CONFIG_64BIT) && !defined(CONFIG_MIPS32_O32)
-	return 1;
-#elif defined(CONFIG_64BIT) && defined(CONFIG_MIPS32_O32)
+	if (cpu_has_fpu)
+		return xcp->cp0_status & ST0_FR;
+#ifdef CONFIG_64BIT
 	return !test_thread_flag(TIF_32BIT_REGS);
 #else
 	return 0;
diff -Naur linux-3.5.4/arch/mips/mm/c-r4k.c linux-2012.09/arch/mips/mm/c-r4k.c
--- linux-3.5.4/arch/mips/mm/c-r4k.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/mm/c-r4k.c	2012-10-27 16:24:02.000000000 +0800
@@ -632,6 +632,9 @@
 		if (size >= scache_size)
 			r4k_blast_scache();
 		else {
+			unsigned long lsize = cpu_scache_line_size();
+			unsigned long almask = ~(lsize - 1);
+
 			/*
 			 * There is no clearly documented alignment requirement
 			 * for the cache instruction on MIPS processors and
@@ -640,6 +643,9 @@
 			 * hit ops with insufficient alignment.  Solved by
 			 * aligning the address to cache line size.
 			 */
+			cache_op(Hit_Writeback_Inv_SD, addr & almask);
+			cache_op(Hit_Writeback_Inv_SD,
+				 (addr + size - 1) & almask);
 			blast_inv_scache_range(addr, addr + size);
 		}
 		__sync();
@@ -649,7 +655,12 @@
 	if (cpu_has_safe_index_cacheops && size >= dcache_size) {
 		r4k_blast_dcache();
 	} else {
+		unsigned long lsize = cpu_dcache_line_size();
+		unsigned long almask = ~(lsize - 1);
+
 		R4600_HIT_CACHEOP_WAR_IMPL;
+		cache_op(Hit_Writeback_Inv_D, addr & almask);
+		cache_op(Hit_Writeback_Inv_D, (addr + size - 1)  & almask);
 		blast_inv_dcache_range(addr, addr + size);
 	}
 
diff -Naur linux-3.5.4/arch/mips/mm/gup.c linux-2012.09/arch/mips/mm/gup.c
--- linux-3.5.4/arch/mips/mm/gup.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/mm/gup.c	2012-10-27 16:24:02.000000000 +0800
@@ -152,8 +152,6 @@
 	do {
 		VM_BUG_ON(compound_head(page) != head);
 		pages[*nr] = page;
-		if (PageTail(page))
-			get_huge_page_tail(page);
 		(*nr)++;
 		page++;
 		refs++;
diff -Naur linux-3.5.4/arch/mips/mm/highmem.c linux-2012.09/arch/mips/mm/highmem.c
--- linux-3.5.4/arch/mips/mm/highmem.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/mm/highmem.c	2012-10-27 16:24:02.000000000 +0800
@@ -1,4 +1,3 @@
-#include <linux/compiler.h>
 #include <linux/module.h>
 #include <linux/highmem.h>
 #include <linux/sched.h>
@@ -68,7 +67,7 @@
 void __kunmap_atomic(void *kvaddr)
 {
 	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
-	int type __maybe_unused;
+	int type;
 
 	if (vaddr < FIXADDR_START) { // FIXME
 		pagefault_enable();
diff -Naur linux-3.5.4/arch/mips/mti-malta/malta-platform.c linux-2012.09/arch/mips/mti-malta/malta-platform.c
--- linux-3.5.4/arch/mips/mti-malta/malta-platform.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/mti-malta/malta-platform.c	2012-10-27 16:24:00.000000000 +0800
@@ -138,6 +138,11 @@
 	if (err)
 		return err;
 
+	/*
+	 * Set RTC to BCD mode to support current alarm code.
+	 */
+	CMOS_WRITE(CMOS_READ(RTC_CONTROL) & ~RTC_DM_BINARY, RTC_CONTROL);
+
 	return 0;
 }
 
diff -Naur linux-3.5.4/arch/mips/netlogic/common/smpboot.S linux-2012.09/arch/mips/netlogic/common/smpboot.S
--- linux-3.5.4/arch/mips/netlogic/common/smpboot.S	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/netlogic/common/smpboot.S	2012-10-27 16:24:01.000000000 +0800
@@ -54,36 +54,28 @@
 			XLP_IO_SYS_OFFSET(node) + XLP_IO_PCI_HDRSZ + \
 			SYS_CPU_NONCOHERENT_MODE * 4
 
-#define	XLP_AX_WORKAROUND	/* enable Ax silicon workarounds */
-
-/* Enable XLP features and workarounds in the LSU */
-.macro xlp_config_lsu
-	li	t0, LSU_DEFEATURE
-	mfcr	t1, t0
-
-	lui	t2, 0x4080	/* Enable Unaligned Access, L2HPE */
-	or	t1, t1, t2
-#ifdef XLP_AX_WORKAROUND
-	li	t2, ~0xe	/* S1RCM */
+.macro __config_lsu
+	li      t0, LSU_DEFEATURE
+	mfcr    t1, t0
+
+	lui     t2, 0x4080  /* Enable Unaligned Access, L2HPE */
+	or      t1, t1, t2
+	li	t2, ~0xe    /* S1RCM */
 	and	t1, t1, t2
-#endif
 	mtcr    t1, t0
 
-#ifdef XLP_AX_WORKAROUND
-	li	t0, SCHED_DEFEATURE
-	lui	t1, 0x0100	/* Disable BRU accepting ALU ops */
-	mtcr	t1, t0
-#endif
+	li      t0, SCHED_DEFEATURE
+	lui     t1, 0x0100  /* Experimental: Disable BRU accepting ALU ops */
+	mtcr    t1, t0
 .endm
 
 /*
- * This is the code that will be copied to the reset entry point for
- * XLR and XLP. The XLP cores start here when they are woken up. This
- * is also the NMI entry point.
+ * The cores can come start when they are woken up. This is also the NMI
+ * entry, so check that first.
  *
- * The data corresponding to reset/NMI is stored at RESET_DATA_PHYS
- * location, this will have the thread mask (used when core is woken up)
- * and the current NMI handler in case we reached here for an NMI.
+ * The data corresponding to reset is stored at RESET_DATA_PHYS location,
+ * this will have the thread mask (used when core is woken up) and the
+ * current NMI handler in case we reached here for an NMI.
  *
  * When a core or thread is newly woken up, it loops in a 'wait'. When
  * the CPU really needs waking up, we send an NMI to it, with the NMI
@@ -97,12 +89,12 @@
 FEXPORT(nlm_reset_entry)
 	dmtc0	k0, $22, 6
 	dmtc0	k1, $22, 7
-	mfc0	k0, CP0_STATUS
-	li	k1, 0x80000
-	and	k1, k0, k1
-	beqz	k1, 1f		/* go to real reset entry */
+	mfc0    k0, CP0_STATUS
+	li      k1, 0x80000
+	and     k1, k0, k1
+	beqz    k1, 1f         /* go to real reset entry */
 	nop
-	li	k1, CKSEG1ADDR(RESET_DATA_PHYS)	/* NMI */
+	li	k1, CKSEG1ADDR(RESET_DATA_PHYS)   /* NMI */
 	ld	k0, BOOT_NMI_HANDLER(k1)
 	jr	k0
 	nop
@@ -122,23 +114,21 @@
 	li	t2, SYS_CPU_COHERENT_BASE(0)
 	add	t2, t2, t3		/* t2 <- SYS offset for node */
 	lw	t1, 0(t2)
-	and	t1, t1, t0
-	sw	t1, 0(t2)
+	and     t1, t1, t0
+	sw      t1, 0(t2)
 
 	/* read back to ensure complete */
-	lw	t1, 0(t2)
+	lw      t1, 0(t2)
 	sync
 
 	/* Configure LSU on Non-0 Cores. */
-	xlp_config_lsu
-	/* FALL THROUGH */
+	__config_lsu
 
 /*
  * Wake up sibling threads from the initial thread in
  * a core.
  */
 EXPORT(nlm_boot_siblings)
-	/* Enable hw threads by writing to MAP_THREADMODE of the core */
 	li	t0, CKSEG1ADDR(RESET_DATA_PHYS)
 	lw	t1, BOOT_THREAD_MODE(t0)	/* t1 <- thread mode */
 	li	t0, ((CPU_BLOCKID_MAP << 8) | MAP_THREADMODE)
@@ -149,24 +139,24 @@
 	/*
 	 * The new hardware thread starts at the next instruction
 	 * For all the cases other than core 0 thread 0, we will
-	* jump to the secondary wait function.
-	*/
+         * jump to the secondary wait function.
+         */
 	mfc0	v0, CP0_EBASE, 1
 	andi	v0, 0x7f		/* v0 <- node/core */
 
-	/* Init MMU in the first thread after changing THREAD_MODE
-	 * register (Ax Errata?)
-	 */
+#if 1
+	/* A0 errata - Write MMU_SETUP after changing thread mode register. */
 	andi	v1, v0, 0x3		/* v1 <- thread id */
 	bnez	v1, 2f
 	nop
 
-	li	t0, MMU_SETUP
-	li	t1, 0
-	mtcr	t1, t0
+        li	t0, MMU_SETUP
+        li	t1, 0
+        mtcr	t1, t0
 	ehb
+#endif
 
-2:	beqz	v0, 4f		/* boot cpu (cpuid == 0)? */
+2:	beqz	v0, 4f
 	nop
 
 	/* setup status reg */
@@ -193,9 +183,9 @@
 	 * For the boot CPU, we have to restore registers and
 	 * return
 	 */
-4:	dmfc0	t0, $4, 2	/* restore SP from UserLocal */
+4:	dmfc0	t0, $4, 2       /* restore SP from UserLocal */
 	li	t1, 0xfadebeef
-	dmtc0	t1, $4, 2	/* restore SP from UserLocal */
+	dmtc0	t1, $4, 2       /* restore SP from UserLocal */
 	PTR_SUBU sp, t0, PT_SIZE
 	RESTORE_ALL
 	jr   ra
@@ -203,7 +193,7 @@
 EXPORT(nlm_reset_entry_end)
 
 FEXPORT(xlp_boot_core0_siblings)	/* "Master" cpu starts from here */
-	xlp_config_lsu
+	__config_lsu
 	dmtc0   sp, $4, 2		/* SP saved in UserLocal */
 	SAVE_ALL
 	sync
@@ -244,36 +234,36 @@
  */
 	__CPUINIT
 NESTED(nlm_rmiboot_preboot, 16, sp)
-	mfc0	t0, $15, 1	/* read ebase */
-	andi	t0, 0x1f	/* t0 has the processor_id() */
-	andi	t2, t0, 0x3	/* thread num */
-	sll	t0, 2		/* offset in cpu array */
+	mfc0	t0, $15, 1	# read ebase
+	andi	t0, 0x1f	# t0 has the processor_id()
+	andi	t2, t0, 0x3	# thread no
+	sll	t0, 2		# offset in cpu array
 
-	PTR_LA	t1, nlm_cpu_ready /* mark CPU ready */
+	PTR_LA	t1, nlm_cpu_ready # mark CPU ready
 	PTR_ADDU t1, t0
 	li	t3, 1
 	sw	t3, 0(t1)
 
-	bnez	t2, 1f		/* skip thread programming */
-	nop			/* for thread id != 0 */
+	bnez	t2, 1f		# skip thread programming
+	nop			# for non zero hw threads
 
 	/*
-	 * XLR MMU setup only for first thread in core
+	 * MMU setup only for first thread in core
 	 */
 	li	t0, 0x400
 	mfcr	t1, t0
-	li	t2, 6 		/* XLR thread mode mask */
+	li	t2, 6 		# XLR thread mode mask
 	nor	t3, t2, zero
-	and	t2, t1, t2	/* t2 - current thread mode */
+	and	t2, t1, t2	# t2 - current thread mode
 	li	v0, CKSEG1ADDR(RESET_DATA_PHYS)
-	lw	v1, BOOT_THREAD_MODE(v0) /* v1 - new thread mode */
+	lw	v1, BOOT_THREAD_MODE(v0) # v1 - new thread mode
 	sll	v1, 1
-	beq	v1, t2, 1f 	/* same as request value */
-	nop			/* nothing to do */
+	beq	v1, t2, 1f 	# same as request value
+	nop			# nothing to do */
 
-	and	t2, t1, t3	/* mask out old thread mode */
-	or	t1, t2, v1	/* put in new value */
-	mtcr	t1, t0		/* update core control */
+	and	t2, t1, t3	# mask out old thread mode
+	or	t1, t2, v1	# put in new value
+	mtcr	t1, t0		# update core control
 
 1:	wait
 	j	1b
diff -Naur linux-3.5.4/arch/mips/pci/fixup-cobalt.c linux-2012.09/arch/mips/pci/fixup-cobalt.c
--- linux-3.5.4/arch/mips/pci/fixup-cobalt.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/pci/fixup-cobalt.c	2012-10-27 16:24:01.000000000 +0800
@@ -37,7 +37,7 @@
 #define VIA_COBALT_BRD_ID_REG  0x94
 #define VIA_COBALT_BRD_REG_to_ID(reg)	((unsigned char)(reg) >> 4)
 
-static void __devinit qube_raq_galileo_early_fixup(struct pci_dev *dev)
+static void qube_raq_galileo_early_fixup(struct pci_dev *dev)
 {
 	if (dev->devfn == PCI_DEVFN(0, 0) &&
 		(dev->class >> 8) == PCI_CLASS_MEMORY_OTHER) {
@@ -51,7 +51,7 @@
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_MARVELL, PCI_DEVICE_ID_MARVELL_GT64111,
 	 qube_raq_galileo_early_fixup);
 
-static void __devinit qube_raq_via_bmIDE_fixup(struct pci_dev *dev)
+static void qube_raq_via_bmIDE_fixup(struct pci_dev *dev)
 {
 	unsigned short cfgword;
 	unsigned char lt;
@@ -74,7 +74,7 @@
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C586_1,
 	 qube_raq_via_bmIDE_fixup);
 
-static void __devinit qube_raq_galileo_fixup(struct pci_dev *dev)
+static void qube_raq_galileo_fixup(struct pci_dev *dev)
 {
 	if (dev->devfn != PCI_DEVFN(0, 0))
 		return;
@@ -129,7 +129,7 @@
 
 int cobalt_board_id;
 
-static void __devinit qube_raq_via_board_id_fixup(struct pci_dev *dev)
+static void qube_raq_via_board_id_fixup(struct pci_dev *dev)
 {
 	u8 id;
 	int retval;
diff -Naur linux-3.5.4/arch/mips/pci/fixup-malta.c linux-2012.09/arch/mips/pci/fixup-malta.c
--- linux-3.5.4/arch/mips/pci/fixup-malta.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/pci/fixup-malta.c	2012-10-27 16:24:01.000000000 +0800
@@ -101,17 +101,3 @@
 
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB,
 	 malta_piix_func1_fixup);
-
-/* Enable PCI 2.1 compatibility in PIIX4 */
-static void __devinit quirk_dlcsetup(struct pci_dev *dev)
-{
-	u8 odlc, ndlc;
-
-	(void) pci_read_config_byte(dev, 0x82, &odlc);
-	/* Enable passive releases and delayed transaction */
-	ndlc = odlc | 7;
-	(void) pci_write_config_byte(dev, 0x82, ndlc);
-}
-
-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB_0,
-	quirk_dlcsetup);
diff -Naur linux-3.5.4/arch/mips/pci/fixup-rc32434.c linux-2012.09/arch/mips/pci/fixup-rc32434.c
--- linux-3.5.4/arch/mips/pci/fixup-rc32434.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/pci/fixup-rc32434.c	2012-10-27 16:24:01.000000000 +0800
@@ -47,7 +47,7 @@
 	return irq + GROUP4_IRQ_BASE + 4;
 }
 
-static void __devinit rc32434_pci_early_fixup(struct pci_dev *dev)
+static void rc32434_pci_early_fixup(struct pci_dev *dev)
 {
 	if (PCI_SLOT(dev->devfn) == 6 && dev->bus->number == 0) {
 		/* disable prefetched memory range */
diff -Naur linux-3.5.4/arch/mips/pci/ops-bcm63xx.c linux-2012.09/arch/mips/pci/ops-bcm63xx.c
--- linux-3.5.4/arch/mips/pci/ops-bcm63xx.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/pci/ops-bcm63xx.c	2012-10-27 16:24:01.000000000 +0800
@@ -411,7 +411,7 @@
  * only one IO window, so it  cannot be shared by PCI and cardbus, use
  * fixup to choose and detect unhandled configuration
  */
-static void __devinit bcm63xx_fixup(struct pci_dev *dev)
+static void bcm63xx_fixup(struct pci_dev *dev)
 {
 	static int io_window = -1;
 	int i, found, new_io_window;
diff -Naur linux-3.5.4/arch/mips/pci/ops-bridge.c linux-2012.09/arch/mips/pci/ops-bridge.c
--- linux-3.5.4/arch/mips/pci/ops-bridge.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/pci/ops-bridge.c	2012-10-27 16:24:01.000000000 +0800
@@ -56,7 +56,7 @@
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't even give the
+	 * IOC3 is fucked fucked beyond believe ...  Don't even give the
 	 * generic PCI code a chance to look at it for real ...
 	 */
 	if (cf == (PCI_VENDOR_ID_SGI | (PCI_DEVICE_ID_SGI_IOC3 << 16)))
@@ -76,7 +76,7 @@
 oh_my_gawd:
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't even give the
+	 * IOC3 is fucked fucked beyond believe ...  Don't even give the
 	 * generic PCI code a chance to look at the wrong register.
 	 */
 	if ((where >= 0x14 && where < 0x40) || (where >= 0x48)) {
@@ -85,7 +85,7 @@
 	}
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't try to access
+	 * IOC3 is fucked fucked beyond believe ...  Don't try to access
 	 * anything but 32-bit words ...
 	 */
 	addr = &bridge->b_type0_cfg_dev[slot].f[fn].l[where >> 2];
@@ -118,7 +118,7 @@
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't even give the
+	 * IOC3 is fucked fucked beyond believe ...  Don't even give the
 	 * generic PCI code a chance to look at it for real ...
 	 */
 	if (cf == (PCI_VENDOR_ID_SGI | (PCI_DEVICE_ID_SGI_IOC3 << 16)))
@@ -139,7 +139,7 @@
 oh_my_gawd:
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't even give the
+	 * IOC3 is fucked fucked beyond believe ...  Don't even give the
 	 * generic PCI code a chance to look at the wrong register.
 	 */
 	if ((where >= 0x14 && where < 0x40) || (where >= 0x48)) {
@@ -148,7 +148,7 @@
 	}
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't try to access
+	 * IOC3 is fucked fucked beyond believe ...  Don't try to access
 	 * anything but 32-bit words ...
 	 */
 	bridge->b_pci_cfg = (busno << 16) | (slot << 11);
@@ -189,7 +189,7 @@
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't even give the
+	 * IOC3 is fucked fucked beyond believe ...  Don't even give the
 	 * generic PCI code a chance to look at it for real ...
 	 */
 	if (cf == (PCI_VENDOR_ID_SGI | (PCI_DEVICE_ID_SGI_IOC3 << 16)))
@@ -213,14 +213,14 @@
 oh_my_gawd:
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't even give the
+	 * IOC3 is fucked fucked beyond believe ...  Don't even give the
 	 * generic PCI code a chance to touch the wrong register.
 	 */
 	if ((where >= 0x14 && where < 0x40) || (where >= 0x48))
 		return PCIBIOS_SUCCESSFUL;
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't try to access
+	 * IOC3 is fucked fucked beyond believe ...  Don't try to access
 	 * anything but 32-bit words ...
 	 */
 	addr = &bridge->b_type0_cfg_dev[slot].f[fn].l[where >> 2];
@@ -257,7 +257,7 @@
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't even give the
+	 * IOC3 is fucked fucked beyond believe ...  Don't even give the
 	 * generic PCI code a chance to look at it for real ...
 	 */
 	if (cf == (PCI_VENDOR_ID_SGI | (PCI_DEVICE_ID_SGI_IOC3 << 16)))
@@ -281,14 +281,14 @@
 oh_my_gawd:
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't even give the
+	 * IOC3 is fucked fucked beyond believe ...  Don't even give the
 	 * generic PCI code a chance to touch the wrong register.
 	 */
 	if ((where >= 0x14 && where < 0x40) || (where >= 0x48))
 		return PCIBIOS_SUCCESSFUL;
 
 	/*
-	 * IOC3 is fucking fucked beyond belief ...  Don't try to access
+	 * IOC3 is fucked fucked beyond believe ...  Don't try to access
 	 * anything but 32-bit words ...
 	 */
 	addr = &bridge->b_type0_cfg_dev[slot].f[fn].l[where >> 2];
diff -Naur linux-3.5.4/arch/mips/pci/pci-xlr.c linux-2012.09/arch/mips/pci/pci-xlr.c
--- linux-3.5.4/arch/mips/pci/pci-xlr.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/pci/pci-xlr.c	2012-10-27 16:24:01.000000000 +0800
@@ -375,3 +375,7 @@
 }
 
 arch_initcall(pcibios_init);
+
+struct pci_fixup pcibios_fixups[] = {
+	{0}
+};
diff -Naur linux-3.5.4/arch/mips/powertv/init.c linux-2012.09/arch/mips/powertv/init.c
--- linux-3.5.4/arch/mips/powertv/init.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/powertv/init.c	2012-10-27 16:24:01.000000000 +0800
@@ -69,6 +69,40 @@
 	return result;
 }
 
+/* TODO: Verify on linux-mips mailing list that the following two  */
+/* functions are correct                                           */
+/* TODO: Copy NMI and EJTAG exception vectors to memory from the   */
+/* BootROM exception vectors. Flush their cache entries. test it.  */
+
+static void __init mips_nmi_setup(void)
+{
+	void *base;
+#if defined(CONFIG_CPU_MIPS32_R1)
+	base = cpu_has_veic ?
+		(void *)(CAC_BASE + 0xa80) :
+		(void *)(CAC_BASE + 0x380);
+#elif defined(CONFIG_CPU_MIPS32_R2)
+	base = (void *)0xbfc00000;
+#else
+#error NMI exception handler address not defined
+#endif
+}
+
+static void __init mips_ejtag_setup(void)
+{
+	void *base;
+
+#if defined(CONFIG_CPU_MIPS32_R1)
+	base = cpu_has_veic ?
+		(void *)(CAC_BASE + 0xa00) :
+		(void *)(CAC_BASE + 0x300);
+#elif defined(CONFIG_CPU_MIPS32_R2)
+	base = (void *)0xbfc00480;
+#else
+#error EJTAG exception handler address not defined
+#endif
+}
+
 void __init prom_init(void)
 {
 	int prom_argc;
@@ -79,6 +113,9 @@
 	_prom_envp = (int *) fw_arg2;
 	_prom_memsize = (unsigned long) fw_arg3;
 
+	board_nmi_handler_setup = mips_nmi_setup;
+	board_ejtag_handler_setup = mips_ejtag_setup;
+
 	if (prom_argc == 1) {
 		strlcat(arcs_cmdline, " ", COMMAND_LINE_SIZE);
 		strlcat(arcs_cmdline, prom_argv, COMMAND_LINE_SIZE);
diff -Naur linux-3.5.4/arch/mips/rb532/prom.c linux-2012.09/arch/mips/rb532/prom.c
--- linux-3.5.4/arch/mips/rb532/prom.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/rb532/prom.c	2012-10-27 16:24:00.000000000 +0800
@@ -72,11 +72,12 @@
 	static char cmd_line[COMMAND_LINE_SIZE] __initdata;
 	char *cp, *board;
 	int prom_argc;
-	char **prom_argv;
+	char **prom_argv, **prom_envp;
 	int i;
 
 	prom_argc = fw_arg0;
 	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
 
 	cp = cmd_line;
 		/* Note: it is common that parameters start
diff -Naur linux-3.5.4/arch/mips/sgi-ip22/ip22-eisa.c linux-2012.09/arch/mips/sgi-ip22/ip22-eisa.c
--- linux-3.5.4/arch/mips/sgi-ip22/ip22-eisa.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/sgi-ip22/ip22-eisa.c	2012-10-27 16:24:00.000000000 +0800
@@ -73,10 +73,12 @@
 
 static irqreturn_t ip22_eisa_intr(int irq, void *dev_id)
 {
-	u8 eisa_irq = inb(EIU_INTRPT_ACK);
+	u8 eisa_irq;
+	u8 dma1, dma2;
 
-	inb(EISA_DMA1_STATUS);
-	inb(EISA_DMA2_STATUS);
+	eisa_irq = inb(EIU_INTRPT_ACK);
+	dma1 = inb(EISA_DMA1_STATUS);
+	dma2 = inb(EISA_DMA2_STATUS);
 
 	if (eisa_irq < EISA_MAX_IRQ) {
 		do_IRQ(eisa_irq);
diff -Naur linux-3.5.4/arch/mips/txx9/generic/pci.c linux-2012.09/arch/mips/txx9/generic/pci.c
--- linux-3.5.4/arch/mips/txx9/generic/pci.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/txx9/generic/pci.c	2012-10-27 16:24:01.000000000 +0800
@@ -304,7 +304,7 @@
 	smsc_fdc37m81x_config_end();
 }
 
-static void __devinit quirk_slc90e66_ide(struct pci_dev *dev)
+static void quirk_slc90e66_ide(struct pci_dev *dev)
 {
 	unsigned char dat;
 	int regs[2] = {0x41, 0x43};
@@ -339,7 +339,7 @@
 }
 #endif /* CONFIG_TOSHIBA_FPCIB0 */
 
-static void __devinit tc35815_fixup(struct pci_dev *dev)
+static void tc35815_fixup(struct pci_dev *dev)
 {
 	/* This device may have PM registers but not they are not suported. */
 	if (dev->pm_cap) {
@@ -348,7 +348,7 @@
 	}
 }
 
-static void __devinit final_fixup(struct pci_dev *dev)
+static void final_fixup(struct pci_dev *dev)
 {
 	unsigned char bist;
 
diff -Naur linux-3.5.4/arch/mips/wrppmc/pci.c linux-2012.09/arch/mips/wrppmc/pci.c
--- linux-3.5.4/arch/mips/wrppmc/pci.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/arch/mips/wrppmc/pci.c	2012-10-27 16:24:01.000000000 +0800
@@ -38,8 +38,10 @@
 
 static int __init gt64120_pci_init(void)
 {
-	(void) GT_READ(GT_PCI0_CMD_OFS);	/* Huh??? -- Ralf  */
-	(void) GT_READ(GT_PCI0_BARE_OFS);
+	u32 tmp;
+
+	tmp = GT_READ(GT_PCI0_CMD_OFS);		/* Huh??? -- Ralf  */
+	tmp = GT_READ(GT_PCI0_BARE_OFS);
 
 	/* reset the whole PCI I/O space range */
 	ioport_resource.start = GT_PCI_IO_BASE;
diff -Naur linux-3.5.4/drivers/net/ethernet/Kconfig linux-2012.09/drivers/net/ethernet/Kconfig
--- linux-3.5.4/drivers/net/ethernet/Kconfig	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/drivers/net/ethernet/Kconfig	2012-10-27 16:24:34.000000000 +0800
@@ -143,7 +143,6 @@
 
 source "drivers/net/ethernet/packetengines/Kconfig"
 source "drivers/net/ethernet/pasemi/Kconfig"
-source "drivers/net/ethernet/pmc-sierra/Kconfig"
 source "drivers/net/ethernet/qlogic/Kconfig"
 source "drivers/net/ethernet/racal/Kconfig"
 source "drivers/net/ethernet/realtek/Kconfig"
diff -Naur linux-3.5.4/drivers/net/ethernet/Makefile linux-2012.09/drivers/net/ethernet/Makefile
--- linux-3.5.4/drivers/net/ethernet/Makefile	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/drivers/net/ethernet/Makefile	2012-10-27 16:24:34.000000000 +0800
@@ -53,7 +53,6 @@
 obj-$(CONFIG_ETHOC) += ethoc.o
 obj-$(CONFIG_NET_PACKET_ENGINE) += packetengines/
 obj-$(CONFIG_NET_VENDOR_PASEMI) += pasemi/
-obj-$(CONFIG_NET_VENDOR_PMC_SIERRA) += pmc-sierra/
 obj-$(CONFIG_NET_VENDOR_QLOGIC) += qlogic/
 obj-$(CONFIG_NET_VENDOR_RACAL) += racal/
 obj-$(CONFIG_NET_VENDOR_REALTEK) += realtek/
diff -Naur linux-3.5.4/drivers/net/ethernet/pmc-sierra/Kconfig linux-2012.09/drivers/net/ethernet/pmc-sierra/Kconfig
--- linux-3.5.4/drivers/net/ethernet/pmc-sierra/Kconfig	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/drivers/net/ethernet/pmc-sierra/Kconfig	1970-01-01 08:00:00.000000000 +0800
@@ -1,16 +0,0 @@
-config NET_VENDOR_PMC_SIERRA
-        bool "PMC-Sierra devices"
-        default y
-        depends on PMC_YOSEMITE
-
-if NET_VENDOR_PMC_SIERRA
-
-config TITAN_GE
-	bool "PMC-Sierra TITAN Gigabit Ethernet Support"
-	depends on PMC_YOSEMITE
-        default y
-	help
-	  This enables support for the the integrated ethernet of
-	  PMC-Sierra's Titan SoC.
-
-endif # NET_VENDOR_PMC_SIERRA
diff -Naur linux-3.5.4/drivers/net/ethernet/pmc-sierra/Makefile linux-2012.09/drivers/net/ethernet/pmc-sierra/Makefile
--- linux-3.5.4/drivers/net/ethernet/pmc-sierra/Makefile	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/drivers/net/ethernet/pmc-sierra/Makefile	1970-01-01 08:00:00.000000000 +0800
@@ -1 +0,0 @@
-obj-$(CONFIG_TITAN_GE) += titan_mdio.o titan_ge.o
diff -Naur linux-3.5.4/drivers/net/ethernet/pmc-sierra/titan_ge.c linux-2012.09/drivers/net/ethernet/pmc-sierra/titan_ge.c
--- linux-3.5.4/drivers/net/ethernet/pmc-sierra/titan_ge.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/drivers/net/ethernet/pmc-sierra/titan_ge.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,2069 +0,0 @@
-/*
- * drivers/net/titan_ge.c - Driver for Titan ethernet ports
- *
- * Copyright (C) 2003 PMC-Sierra Inc.
- * Author : Manish Lachwani (lachwani@pmc-sierra.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-/*
- * The MAC unit of the Titan consists of the following:
- *
- * -> XDMA Engine to move data to from the memory to the MAC packet FIFO
- * -> FIFO is where the incoming and outgoing data is placed
- * -> TRTG is the unit that pulls the data from the FIFO for Tx and pushes
- *    the data into the FIFO for Rx
- * -> TMAC is the outgoing MAC interface and RMAC is the incoming.
- * -> AFX is the address filtering block
- * -> GMII block to communicate with the PHY
- *
- * Rx will look like the following:
- * GMII --> RMAC --> AFX --> TRTG --> Rx FIFO --> XDMA --> CPU memory
- *
- * Tx will look like the following:
- * CPU memory --> XDMA --> Tx FIFO --> TRTG --> TMAC --> GMII
- *
- * The Titan driver has support for the following performance features:
- * -> Rx side checksumming
- * -> Jumbo Frames
- * -> Interrupt Coalscing
- * -> Rx NAPI
- * -> SKB Recycling
- * -> Transmit/Receive descriptors in SRAM
- * -> Fast routing for IP forwarding
- */
-
-#include <linux/dma-mapping.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/ioport.h>
-#include <linux/interrupt.h>
-#include <linux/slab.h>
-#include <linux/string.h>
-#include <linux/errno.h>
-#include <linux/ip.h>
-#include <linux/init.h>
-#include <linux/in.h>
-#include <linux/platform_device.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/mii.h>
-#include <linux/delay.h>
-#include <linux/skbuff.h>
-#include <linux/prefetch.h>
-
-/* For MII specifc registers, titan_mdio.h should be included */
-#include <net/ip.h>
-
-#include <asm/bitops.h>
-#include <asm/io.h>
-#include <asm/types.h>
-#include <asm/pgtable.h>
-#include <asm/system.h>
-#include <asm/titan_dep.h>
-
-#include "titan_ge.h"
-#include "titan_mdio.h"
-
-/* Static Function Declarations	 */
-static int titan_ge_eth_open(struct net_device *);
-static void titan_ge_eth_stop(struct net_device *);
-static struct net_device_stats *titan_ge_get_stats(struct net_device *);
-static int titan_ge_init_rx_desc_ring(titan_ge_port_info *, int, int,
-				      unsigned long, unsigned long,
-				      unsigned long);
-static int titan_ge_init_tx_desc_ring(titan_ge_port_info *, int,
-				      unsigned long, unsigned long);
-
-static int titan_ge_open(struct net_device *);
-static int titan_ge_start_xmit(struct sk_buff *, struct net_device *);
-static int titan_ge_stop(struct net_device *);
-
-static unsigned long titan_ge_tx_coal(unsigned long, int);
-
-static void titan_ge_port_reset(unsigned int);
-static int titan_ge_free_tx_queue(titan_ge_port_info *);
-static int titan_ge_rx_task(struct net_device *, titan_ge_port_info *);
-static int titan_ge_port_start(struct net_device *, titan_ge_port_info *);
-
-static int titan_ge_return_tx_desc(titan_ge_port_info *, int);
-
-/*
- * Some configuration for the FIFO and the XDMA channel needs
- * to be done only once for all the ports. This flag controls
- * that
- */
-static unsigned long config_done;
-
-/*
- * One time out of memory flag
- */
-static unsigned int oom_flag;
-
-static int titan_ge_poll(struct net_device *netdev, int *budget);
-
-static int titan_ge_receive_queue(struct net_device *, unsigned int);
-
-static struct platform_device *titan_ge_device[3];
-
-/* MAC Address */
-extern unsigned char titan_ge_mac_addr_base[6];
-
-unsigned long titan_ge_base;
-static unsigned long titan_ge_sram;
-
-static char titan_string[] = "titan";
-
-/*
- * The Titan GE has two alignment requirements:
- * -> skb->data to be cacheline aligned (32 byte)
- * -> IP header alignment to 16 bytes
- *
- * The latter is not implemented. So, that results in an extra copy on
- * the Rx. This is a big performance hog. For the former case, the
- * dev_alloc_skb() has been replaced with titan_ge_alloc_skb(). The size
- * requested is calculated:
- *
- * Ethernet Frame Size : 1518
- * Ethernet Header     : 14
- * Future Titan change for IP header alignment : 2
- *
- * Hence, we allocate (1518 + 14 + 2+ 64) = 1580 bytes.  For IP header
- * alignment, we use skb_reserve().
- */
-
-#define ALIGNED_RX_SKB_ADDR(addr) \
-	((((unsigned long)(addr) + (64UL - 1UL)) \
-	& ~(64UL - 1UL)) - (unsigned long)(addr))
-
-#define titan_ge_alloc_skb(__length, __gfp_flags) \
-({      struct sk_buff *__skb; \
-	__skb = alloc_skb((__length) + 64, (__gfp_flags)); \
-	if(__skb) { \
-		int __offset = (int) ALIGNED_RX_SKB_ADDR(__skb->data); \
-		if(__offset) \
-			skb_reserve(__skb, __offset); \
-	} \
-	__skb; \
-})
-
-/*
- * Configure the GMII block of the Titan based on what the PHY tells us
- */
-static void titan_ge_gmii_config(int port_num)
-{
-	unsigned int reg_data = 0, phy_reg;
-	int err;
-
-	err = titan_ge_mdio_read(port_num, TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
-
-	if (err == TITAN_GE_MDIO_ERROR) {
-		printk(KERN_ERR
-		       "Could not read PHY control register 0x11 \n");
-		printk(KERN_ERR
-			"Setting speed to 1000 Mbps and Duplex to Full \n");
-
-		return;
-	}
-
-	err = titan_ge_mdio_write(port_num, TITAN_GE_MDIO_PHY_IE, 0);
-
-	if (phy_reg & 0x8000) {
-		if (phy_reg & 0x2000) {
-			/* Full Duplex and 1000 Mbps */
-			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
-					(port_num << 12)), 0x201);
-		}  else {
-			/* Half Duplex and 1000 Mbps */
-			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
-					(port_num << 12)), 0x2201);
-			}
-	}
-	if (phy_reg & 0x4000) {
-		if (phy_reg & 0x2000) {
-			/* Full Duplex and 100 Mbps */
-			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
-					(port_num << 12)), 0x100);
-		} else {
-			/* Half Duplex and 100 Mbps */
-			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
-					(port_num << 12)), 0x2100);
-		}
-	}
-	reg_data = TITAN_GE_READ(TITAN_GE_GMII_CONFIG_GENERAL +
-				(port_num << 12));
-	reg_data |= 0x3;
-	TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_GENERAL +
-			(port_num << 12)), reg_data);
-}
-
-/*
- * Enable the TMAC if it is not
- */
-static void titan_ge_enable_tx(unsigned int port_num)
-{
-	unsigned long reg_data;
-
-	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + (port_num << 12));
-	if (!(reg_data & 0x8000)) {
-		printk("TMAC disabled for port %d!! \n", port_num);
-
-		reg_data |= 0x0001;	/* Enable TMAC */
-		reg_data |= 0x4000;	/* CRC Check Enable */
-		reg_data |= 0x2000;	/* Padding enable */
-		reg_data |= 0x0800;	/* CRC Add enable */
-		reg_data |= 0x0080;	/* PAUSE frame */
-
-		TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
-				(port_num << 12)), reg_data);
-	}
-}
-
-/*
- * Tx Timeout function
- */
-static void titan_ge_tx_timeout(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-
-	printk(KERN_INFO "%s: TX timeout  ", netdev->name);
-	printk(KERN_INFO "Resetting card \n");
-
-	/* Do the reset outside of interrupt context */
-	schedule_work(&titan_ge_eth->tx_timeout_task);
-}
-
-/*
- * Update the AFX tables for UC and MC for slice 0 only
- */
-static void titan_ge_update_afx(titan_ge_port_info * titan_ge_eth)
-{
-	int port = titan_ge_eth->port_num;
-	unsigned int i;
-	volatile unsigned long reg_data = 0;
-	u8 p_addr[6];
-
-	memcpy(p_addr, titan_ge_eth->port_mac_addr, 6);
-
-	/* Set the MAC address here for TMAC and RMAC */
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port << 12)),
-		       ((p_addr[5] << 8) | p_addr[4]));
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port << 12)),
-		       ((p_addr[3] << 8) | p_addr[2]));
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port << 12)),
-		       ((p_addr[1] << 8) | p_addr[0]));
-
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port << 12)),
-		       ((p_addr[5] << 8) | p_addr[4]));
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port << 12)),
-		       ((p_addr[3] << 8) | p_addr[2]));
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port << 12)),
-		       ((p_addr[1] << 8) | p_addr[0]));
-
-	TITAN_GE_WRITE((0x112c | (port << 12)), 0x1);
-	/* Configure the eight address filters */
-	for (i = 0; i < 8; i++) {
-		/* Select each of the eight filters */
-		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_2 +
-				(port << 12)), i);
-
-		/* Configure the match */
-		reg_data = 0x9;	/* Forward Enable Bit */
-		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_0 +
-				(port << 12)), reg_data);
-
-		/* Finally, AFX Exact Match Address Registers */
-		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_LOW + (port << 12)),
-			       ((p_addr[1] << 8) | p_addr[0]));
-		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_MID + (port << 12)),
-			       ((p_addr[3] << 8) | p_addr[2]));
-		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_HIGH + (port << 12)),
-			       ((p_addr[5] << 8) | p_addr[4]));
-
-		/* VLAN id set to 0 */
-		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_VID +
-				(port << 12)), 0);
-	}
-}
-
-/*
- * Actual Routine to reset the adapter when the timeout occurred
- */
-static void titan_ge_tx_timeout_task(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	int port = titan_ge_eth->port_num;
-
-	printk("Titan GE: Transmit timed out. Resetting ... \n");
-
-	/* Dump debug info */
-	printk(KERN_ERR "TRTG cause : %x \n",
-			TITAN_GE_READ(0x100c + (port << 12)));
-
-	/* Fix this for the other ports */
-	printk(KERN_ERR "FIFO cause : %x \n", TITAN_GE_READ(0x482c));
-	printk(KERN_ERR "IE cause : %x \n", TITAN_GE_READ(0x0040));
-	printk(KERN_ERR "XDMA GDI ERROR : %x \n",
-			TITAN_GE_READ(0x5008 + (port << 8)));
-	printk(KERN_ERR "CHANNEL ERROR: %x \n",
-			TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT
-						+ (port << 8)));
-
-	netif_device_detach(netdev);
-	titan_ge_port_reset(titan_ge_eth->port_num);
-	titan_ge_port_start(netdev, titan_ge_eth);
-	netif_device_attach(netdev);
-}
-
-/*
- * Change the MTU of the Ethernet Device
- */
-static int titan_ge_change_mtu(struct net_device *netdev, int new_mtu)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned long flags;
-
-	if ((new_mtu > 9500) || (new_mtu < 64))
-		return -EINVAL;
-
-	spin_lock_irqsave(&titan_ge_eth->lock, flags);
-
-	netdev->mtu = new_mtu;
-
-	/* Now we have to reopen the interface so that SKBs with the new
-	 * size will be allocated */
-
-	if (netif_running(netdev)) {
-		titan_ge_eth_stop(netdev);
-
-		if (titan_ge_eth_open(netdev) != TITAN_OK) {
-			printk(KERN_ERR
-			       "%s: Fatal error on opening device\n",
-			       netdev->name);
-			spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-			return -1;
-		}
-	}
-
-	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-	return 0;
-}
-
-/*
- * Titan Gbe Interrupt Handler. All the three ports send interrupt to one line
- * only. Once an interrupt is triggered, figure out the port and then check
- * the channel.
- */
-static irqreturn_t titan_ge_int_handler(int irq, void *dev_id)
-{
-	struct net_device *netdev = (struct net_device *) dev_id;
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	unsigned int reg_data;
-	unsigned int eth_int_cause_error = 0, is;
-	unsigned long eth_int_cause1;
-	int err = 0;
-#ifdef CONFIG_SMP
-	unsigned long eth_int_cause2;
-#endif
-
-	/* Ack the CPU interrupt */
-	switch (port_num) {
-	case 0:
-		is = OCD_READ(RM9000x2_OCD_INTP0STATUS1);
-		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR1, is);
-
-#ifdef CONFIG_SMP
-		is = OCD_READ(RM9000x2_OCD_INTP1STATUS1);
-		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR1, is);
-#endif
-		break;
-
-	case 1:
-		is = OCD_READ(RM9000x2_OCD_INTP0STATUS0);
-		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR0, is);
-
-#ifdef CONFIG_SMP
-		is = OCD_READ(RM9000x2_OCD_INTP1STATUS0);
-		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR0, is);
-#endif
-		break;
-
-	case 2:
-		is = OCD_READ(RM9000x2_OCD_INTP0STATUS4);
-		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR4, is);
-
-#ifdef CONFIG_SMP
-		is = OCD_READ(RM9000x2_OCD_INTP1STATUS4);
-		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR4, is);
-#endif
-	}
-
-	eth_int_cause1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
-#ifdef CONFIG_SMP
-	eth_int_cause2 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_B);
-#endif
-
-	/* Spurious interrupt */
-#ifdef CONFIG_SMP
-	if ( (eth_int_cause1 == 0) && (eth_int_cause2 == 0)) {
-#else
-	if (eth_int_cause1 == 0) {
-#endif
-		eth_int_cause_error = TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT +
-					(port_num << 8));
-
-		if (eth_int_cause_error == 0)
-			return IRQ_NONE;
-	}
-
-	/* Handle Tx first. No need to ack interrupts */
-#ifdef CONFIG_SMP
-	if ( (eth_int_cause1 & 0x20202) ||
-		(eth_int_cause2 & 0x20202) )
-#else
-	if (eth_int_cause1 & 0x20202)
-#endif
-		titan_ge_free_tx_queue(titan_ge_eth);
-
-	/* Handle the Rx next */
-#ifdef CONFIG_SMP
-	if ( (eth_int_cause1 & 0x10101) ||
-		(eth_int_cause2 & 0x10101)) {
-#else
-	if (eth_int_cause1 & 0x10101) {
-#endif
-		if (netif_rx_schedule_prep(netdev)) {
-			unsigned int ack;
-
-			ack = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
-			/* Disable Tx and Rx both */
-			if (port_num == 0)
-				ack &= ~(0x3);
-			if (port_num == 1)
-				ack &= ~(0x300);
-
-			if (port_num == 2)
-				ack &= ~(0x30000);
-
-			/* Interrupts have been disabled */
-			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, ack);
-
-			__netif_rx_schedule(netdev);
-		}
-	}
-
-	/* Handle error interrupts */
-	if (eth_int_cause_error && (eth_int_cause_error != 0x2)) {
-		printk(KERN_ERR
-			"XDMA Channel Error : %x  on port %d\n",
-			eth_int_cause_error, port_num);
-
-		printk(KERN_ERR
-			"XDMA GDI Hardware error : %x  on port %d\n",
-			TITAN_GE_READ(0x5008 + (port_num << 8)), port_num);
-
-		printk(KERN_ERR
-			"XDMA currently has %d Rx descriptors \n",
-			TITAN_GE_READ(0x5048 + (port_num << 8)));
-
-		printk(KERN_ERR
-			"XDMA currently has prefetcted %d Rx descriptors \n",
-			TITAN_GE_READ(0x505c + (port_num << 8)));
-
-		TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT +
-			       (port_num << 8)), eth_int_cause_error);
-	}
-
-	/*
-	 * PHY interrupt to inform abt the changes. Reading the
-	 * PHY Status register will clear the interrupt
-	 */
-	if ((!(eth_int_cause1 & 0x30303)) &&
-		(eth_int_cause_error == 0)) {
-		err =
-		    titan_ge_mdio_read(port_num,
-			       TITAN_GE_MDIO_PHY_IS, &reg_data);
-
-		if (reg_data & 0x0400) {
-			/* Link status change */
-			titan_ge_mdio_read(port_num,
-				   TITAN_GE_MDIO_PHY_STATUS, &reg_data);
-			if (!(reg_data & 0x0400)) {
-				/* Link is down */
-				netif_carrier_off(netdev);
-				netif_stop_queue(netdev);
-			} else {
-				/* Link is up */
-				netif_carrier_on(netdev);
-				netif_wake_queue(netdev);
-
-				/* Enable the queue */
-				titan_ge_enable_tx(port_num);
-			}
-		}
-	}
-
-	return IRQ_HANDLED;
-}
-
-/*
- * Multicast and Promiscuous mode set. The
- * set_multi entry point is called whenever the
- * multicast address list or the network interface
- * flags are updated.
- */
-static void titan_ge_set_multi(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	unsigned long reg_data;
-
-	reg_data = TITAN_GE_READ(TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 +
-				(port_num << 12));
-
-	if (netdev->flags & IFF_PROMISC) {
-		reg_data |= 0x2;
-	}
-	else if (netdev->flags & IFF_ALLMULTI) {
-		reg_data |= 0x01;
-		reg_data |= 0x400; /* Use the 64-bit Multicast Hash bin */
-	}
-	else {
-		reg_data = 0x2;
-	}
-
-	TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 +
-			(port_num << 12)), reg_data);
-	if (reg_data & 0x01) {
-		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_LOW +
-				(port_num << 12)), 0xffff);
-		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDLOW +
-				(port_num << 12)), 0xffff);
-		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDHI +
-				(port_num << 12)), 0xffff);
-		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_HI +
-				(port_num << 12)), 0xffff);
-	}
-}
-
-/*
- * Open the network device
- */
-static int titan_ge_open(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	unsigned int irq = TITAN_ETH_PORT_IRQ - port_num;
-	int retval;
-
-	retval = request_irq(irq, titan_ge_int_handler,
-		     SA_INTERRUPT | SA_SAMPLE_RANDOM , netdev->name, netdev);
-
-	if (retval != 0) {
-		printk(KERN_ERR "Cannot assign IRQ number to TITAN GE \n");
-		return -1;
-	}
-
-	netdev->irq = irq;
-	printk(KERN_INFO "Assigned IRQ %d to port %d\n", irq, port_num);
-
-	spin_lock_irq(&(titan_ge_eth->lock));
-
-	if (titan_ge_eth_open(netdev) != TITAN_OK) {
-		spin_unlock_irq(&(titan_ge_eth->lock));
-		printk("%s: Error opening interface \n", netdev->name);
-		free_irq(netdev->irq, netdev);
-		return -EBUSY;
-	}
-
-	spin_unlock_irq(&(titan_ge_eth->lock));
-
-	return 0;
-}
-
-/*
- * Allocate the SKBs for the Rx ring. Also used
- * for refilling the queue
- */
-static int titan_ge_rx_task(struct net_device *netdev,
-				titan_ge_port_info *titan_ge_port)
-{
-	struct device *device = &titan_ge_device[titan_ge_port->port_num]->dev;
-	volatile titan_ge_rx_desc *rx_desc;
-	struct sk_buff *skb;
-	int rx_used_desc;
-	int count = 0;
-
-	while (titan_ge_port->rx_ring_skbs < titan_ge_port->rx_ring_size) {
-
-	/* First try to get the skb from the recycler */
-#ifdef TITAN_GE_JUMBO_FRAMES
-		skb = titan_ge_alloc_skb(TITAN_GE_JUMBO_BUFSIZE, GFP_ATOMIC);
-#else
-		skb = titan_ge_alloc_skb(TITAN_GE_STD_BUFSIZE, GFP_ATOMIC);
-#endif
-		if (unlikely(!skb)) {
-			/* OOM, set the flag */
-			printk("OOM \n");
-			oom_flag = 1;
-			break;
-		}
-		count++;
-		skb->dev = netdev;
-
-		titan_ge_port->rx_ring_skbs++;
-
-		rx_used_desc = titan_ge_port->rx_used_desc_q;
-		rx_desc = &(titan_ge_port->rx_desc_area[rx_used_desc]);
-
-#ifdef TITAN_GE_JUMBO_FRAMES
-		rx_desc->buffer_addr = dma_map_single(device, skb->data,
-				TITAN_GE_JUMBO_BUFSIZE - 2, DMA_FROM_DEVICE);
-#else
-		rx_desc->buffer_addr = dma_map_single(device, skb->data,
-				TITAN_GE_STD_BUFSIZE - 2, DMA_FROM_DEVICE);
-#endif
-
-		titan_ge_port->rx_skb[rx_used_desc] = skb;
-		rx_desc->cmd_sts = TITAN_GE_RX_BUFFER_OWNED;
-
-		titan_ge_port->rx_used_desc_q =
-			(rx_used_desc + 1) % TITAN_GE_RX_QUEUE;
-	}
-
-	return count;
-}
-
-/*
- * Actual init of the Tital GE port. There is one register for
- * the channel configuration
- */
-static void titan_port_init(struct net_device *netdev,
-			    titan_ge_port_info * titan_ge_eth)
-{
-	unsigned long reg_data;
-
-	titan_ge_port_reset(titan_ge_eth->port_num);
-
-	/* First reset the TMAC */
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
-	reg_data |= 0x80000000;
-	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
-
-	udelay(30);
-
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
-	reg_data &= ~(0xc0000000);
-	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
-
-	/* Now reset the RMAC */
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
-	reg_data |= 0x00080000;
-	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
-
-	udelay(30);
-
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
-	reg_data &= ~(0x000c0000);
-	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
-}
-
-/*
- * Start the port. All the hardware specific configuration
- * for the XDMA, Tx FIFO, Rx FIFO, TMAC, RMAC, TRTG and AFX
- * go here
- */
-static int titan_ge_port_start(struct net_device *netdev,
-				titan_ge_port_info * titan_port)
-{
-	volatile unsigned long reg_data, reg_data1;
-	int port_num = titan_port->port_num;
-	int count = 0;
-	unsigned long reg_data_1;
-
-	if (config_done == 0) {
-		reg_data = TITAN_GE_READ(0x0004);
-		reg_data |= 0x100;
-		TITAN_GE_WRITE(0x0004, reg_data);
-
-		reg_data &= ~(0x100);
-		TITAN_GE_WRITE(0x0004, reg_data);
-
-		/* Turn on GMII/MII mode and turn off TBI mode */
-		reg_data = TITAN_GE_READ(TITAN_GE_TSB_CTRL_1);
-		reg_data |= 0x00000700;
-		reg_data &= ~(0x00800000); /* Fencing */
-
-		TITAN_GE_WRITE(0x000c, 0x00001100);
-
-		TITAN_GE_WRITE(TITAN_GE_TSB_CTRL_1, reg_data);
-
-		/* Set the CPU Resource Limit register */
-		TITAN_GE_WRITE(0x00f8, 0x8);
-
-		/* Be conservative when using the BIU buffers */
-		TITAN_GE_WRITE(0x0068, 0x4);
-	}
-
-	titan_port->tx_threshold = 0;
-	titan_port->rx_threshold = 0;
-
-	/* We need to write the descriptors for Tx and Rx */
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_TX_DESC + (port_num << 8)),
-		       (unsigned long) titan_port->tx_dma);
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_RX_DESC + (port_num << 8)),
-		       (unsigned long) titan_port->rx_dma);
-
-	if (config_done == 0) {
-		/* Step 1:  XDMA config	*/
-		reg_data = TITAN_GE_READ(TITAN_GE_XDMA_CONFIG);
-		reg_data &= ~(0x80000000);      /* clear reset */
-		reg_data |= 0x1 << 29;	/* sparse tx descriptor spacing */
-		reg_data |= 0x1 << 28;	/* sparse rx descriptor spacing */
-		reg_data |= (0x1 << 23) | (0x1 << 24);  /* Descriptor Coherency */
-		reg_data |= (0x1 << 21) | (0x1 << 22);  /* Data Coherency */
-		TITAN_GE_WRITE(TITAN_GE_XDMA_CONFIG, reg_data);
-	}
-
-	/* IR register for the XDMA */
-	reg_data = TITAN_GE_READ(TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8));
-	reg_data |= 0x80068000; /* No Rx_OOD */
-	TITAN_GE_WRITE((TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8)), reg_data);
-
-	/* Start the Tx and Rx XDMA controller */
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG + (port_num << 8));
-	reg_data &= 0x4fffffff;     /* Clear tx reset */
-	reg_data &= 0xfff4ffff;     /* Clear rx reset */
-
-#ifdef TITAN_GE_JUMBO_FRAMES
-	reg_data |= 0xa0 | 0x30030000;
-#else
-	reg_data |= 0x40 | 0x20030000;
-#endif
-
-#ifndef CONFIG_SMP
-	reg_data &= ~(0x10);
-	reg_data |= 0x0f; /* All of the packet */
-#endif
-
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG + (port_num << 8)), reg_data);
-
-	/* Rx desc count */
-	count = titan_ge_rx_task(netdev, titan_port);
-	TITAN_GE_WRITE((0x5048 + (port_num << 8)), count);
-	count = TITAN_GE_READ(0x5048 + (port_num << 8));
-
-	udelay(30);
-
-	/*
-	 * Step 2:  Configure the SDQPF, i.e. FIFO
-	 */
-	if (config_done == 0) {
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
-		reg_data = 0x1;
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
-		reg_data &= ~(0x1);
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
-
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
-		reg_data = 0x1;
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
-		reg_data &= ~(0x1);
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
-	}
-	/*
-	 * Enable RX FIFO 0, 4 and 8
-	 */
-	if (port_num == 0) {
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_0);
-
-		reg_data |= 0x100000;
-		reg_data |= (0xff << 10);
-
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
-		/*
-		 * BAV2,BAV and DAV settings for the Rx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x4844);
-		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
-		TITAN_GE_WRITE(0x4844, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
-
-		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_0);
-		reg_data |= 0x100000;
-
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
-
-		reg_data |= (0xff << 10);
-
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
-
-		/*
-		 * BAV2, BAV and DAV settings for the Tx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x4944);
-		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
-
-		TITAN_GE_WRITE(0x4944, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
-
-	}
-
-	if (port_num == 1) {
-		reg_data = TITAN_GE_READ(0x4870);
-
-		reg_data |= 0x100000;
-		reg_data |= (0xff << 10) | (0xff + 1);
-
-		TITAN_GE_WRITE(0x4870, reg_data);
-		/*
-		 * BAV2,BAV and DAV settings for the Rx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x4874);
-		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
-		TITAN_GE_WRITE(0x4874, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x4870, reg_data);
-
-		reg_data = TITAN_GE_READ(0x494c);
-		reg_data |= 0x100000;
-
-		TITAN_GE_WRITE(0x494c, reg_data);
-		reg_data |= (0xff << 10) | (0xff + 1);
-		TITAN_GE_WRITE(0x494c, reg_data);
-
-		/*
-		 * BAV2, BAV and DAV settings for the Tx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x4950);
-		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
-
-		TITAN_GE_WRITE(0x4950, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x494c, reg_data);
-	}
-
-	/*
-	 * Titan 1.2 revision does support port #2
-	 */
-	if (port_num == 2) {
-		/*
-		 * Put the descriptors in the SRAM
-		 */
-		reg_data = TITAN_GE_READ(0x48a0);
-
-		reg_data |= 0x100000;
-		reg_data |= (0xff << 10) | (2*(0xff + 1));
-
-		TITAN_GE_WRITE(0x48a0, reg_data);
-		/*
-		 * BAV2,BAV and DAV settings for the Rx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x48a4);
-		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
-		TITAN_GE_WRITE(0x48a4, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x48a0, reg_data);
-
-		reg_data = TITAN_GE_READ(0x4958);
-		reg_data |= 0x100000;
-
-		TITAN_GE_WRITE(0x4958, reg_data);
-		reg_data |= (0xff << 10) | (2*(0xff + 1));
-		TITAN_GE_WRITE(0x4958, reg_data);
-
-		/*
-		 * BAV2, BAV and DAV settings for the Tx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x495c);
-		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
-
-		TITAN_GE_WRITE(0x495c, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x4958, reg_data);
-	}
-
-	if (port_num == 2) {
-		reg_data = TITAN_GE_READ(0x48a0);
-
-		reg_data |= 0x100000;
-		reg_data |= (0xff << 10) | (2*(0xff + 1));
-
-		TITAN_GE_WRITE(0x48a0, reg_data);
-		/*
-		 * BAV2,BAV and DAV settings for the Rx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x48a4);
-		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
-		TITAN_GE_WRITE(0x48a4, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x48a0, reg_data);
-
-		reg_data = TITAN_GE_READ(0x4958);
-		reg_data |= 0x100000;
-
-		TITAN_GE_WRITE(0x4958, reg_data);
-		reg_data |= (0xff << 10) | (2*(0xff + 1));
-		TITAN_GE_WRITE(0x4958, reg_data);
-
-		/*
-		 * BAV2, BAV and DAV settings for the Tx FIFO
-		 */
-		reg_data1 = TITAN_GE_READ(0x495c);
-		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
-
-		TITAN_GE_WRITE(0x495c, reg_data1);
-
-		reg_data &= ~(0x00100000);
-		reg_data |= 0x200000;
-
-		TITAN_GE_WRITE(0x4958, reg_data);
-	}
-
-	/*
-	 * Step 3:  TRTG block enable
-	 */
-	reg_data = TITAN_GE_READ(TITAN_GE_TRTG_CONFIG + (port_num << 12));
-
-	/*
-	 * This is the 1.2 revision of the chip. It has fix for the
-	 * IP header alignment. Now, the IP header begins at an
-	 * aligned address and this wont need an extra copy in the
-	 * driver. This performance drawback existed in the previous
-	 * versions of the silicon
-	 */
-	reg_data_1 = TITAN_GE_READ(0x103c + (port_num << 12));
-	reg_data_1 |= 0x40000000;
-	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
-
-	reg_data_1 |= 0x04000000;
-	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
-
-	mdelay(5);
-
-	reg_data_1 &= ~(0x04000000);
-	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
-
-	mdelay(5);
-
-	reg_data |= 0x0001;
-	TITAN_GE_WRITE((TITAN_GE_TRTG_CONFIG + (port_num << 12)), reg_data);
-
-	/*
-	 * Step 4:  Start the Tx activity
-	 */
-	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_2 + (port_num << 12)), 0xe197);
-#ifdef TITAN_GE_JUMBO_FRAMES
-	TITAN_GE_WRITE((0x1258 + (port_num << 12)), 0x4000);
-#endif
-	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + (port_num << 12));
-	reg_data |= 0x0001;	/* Enable TMAC */
-	reg_data |= 0x6c70;	/* PAUSE also set */
-
-	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 + (port_num << 12)), reg_data);
-
-	udelay(30);
-
-	/* Destination Address drop bit */
-	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_2 + (port_num << 12));
-	reg_data |= 0x218;        /* DA_DROP bit and pause */
-	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_2 + (port_num << 12)), reg_data);
-
-	TITAN_GE_WRITE((0x1218 + (port_num << 12)), 0x3);
-
-#ifdef TITAN_GE_JUMBO_FRAMES
-	TITAN_GE_WRITE((0x1208 + (port_num << 12)), 0x4000);
-#endif
-	/* Start the Rx activity */
-	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + (port_num << 12));
-	reg_data |= 0x0001;	/* RMAC Enable */
-	reg_data |= 0x0010;	/* CRC Check enable */
-	reg_data |= 0x0040;	/* Min Frame check enable */
-	reg_data |= 0x4400;	/* Max Frame check enable */
-
-	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + (port_num << 12)), reg_data);
-
-	udelay(30);
-
-	/*
-	 * Enable the Interrupts for Tx and Rx
-	 */
-	reg_data1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
-
-	if (port_num == 0) {
-		reg_data1 |= 0x3;
-#ifdef CONFIG_SMP
-		TITAN_GE_WRITE(0x0038, 0x003);
-#else
-		TITAN_GE_WRITE(0x0038, 0x303);
-#endif
-	}
-
-	if (port_num == 1) {
-		reg_data1 |= 0x300;
-	}
-
-	if (port_num == 2)
-		reg_data1 |= 0x30000;
-
-	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data1);
-	TITAN_GE_WRITE(0x003c, 0x300);
-
-	if (config_done == 0) {
-		TITAN_GE_WRITE(0x0024, 0x04000024);	/* IRQ vector */
-		TITAN_GE_WRITE(0x0020, 0x000fb000);	/* INTMSG base */
-	}
-
-	/* Priority */
-	reg_data = TITAN_GE_READ(0x1038 + (port_num << 12));
-	reg_data &= ~(0x00f00000);
-	TITAN_GE_WRITE((0x1038 + (port_num << 12)), reg_data);
-
-	/* Step 5:  GMII config */
-	titan_ge_gmii_config(port_num);
-
-	if (config_done == 0) {
-		TITAN_GE_WRITE(0x1a80, 0);
-		config_done = 1;
-	}
-
-	return TITAN_OK;
-}
-
-/*
- * Function to queue the packet for the Ethernet device
- */
-static void titan_ge_tx_queue(titan_ge_port_info * titan_ge_eth,
-				struct sk_buff * skb)
-{
-	struct device *device = &titan_ge_device[titan_ge_eth->port_num]->dev;
-	unsigned int curr_desc = titan_ge_eth->tx_curr_desc_q;
-	volatile titan_ge_tx_desc *tx_curr;
-	int port_num = titan_ge_eth->port_num;
-
-	tx_curr = &(titan_ge_eth->tx_desc_area[curr_desc]);
-	tx_curr->buffer_addr =
-		dma_map_single(device, skb->data, skb_headlen(skb),
-			       DMA_TO_DEVICE);
-
-	titan_ge_eth->tx_skb[curr_desc] = (struct sk_buff *) skb;
-	tx_curr->buffer_len = skb_headlen(skb);
-
-	/* Last descriptor enables interrupt and changes ownership */
-	tx_curr->cmd_sts = 0x1 | (1 << 15) | (1 << 5);
-
-	/* Kick the XDMA to start the transfer from memory to the FIFO */
-	TITAN_GE_WRITE((0x5044 + (port_num << 8)), 0x1);
-
-	/* Current descriptor updated */
-	titan_ge_eth->tx_curr_desc_q = (curr_desc + 1) % TITAN_GE_TX_QUEUE;
-
-	/* Prefetch the next descriptor */
-	prefetch((const void *)
-		 &titan_ge_eth->tx_desc_area[titan_ge_eth->tx_curr_desc_q]);
-}
-
-/*
- * Actually does the open of the Ethernet device
- */
-static int titan_ge_eth_open(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	struct device *device = &titan_ge_device[port_num]->dev;
-	unsigned long reg_data;
-	unsigned int phy_reg;
-	int err = 0;
-
-	/* Stop the Rx activity */
-	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + (port_num << 12));
-	reg_data &= ~(0x00000001);
-	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + (port_num << 12)), reg_data);
-
-	/* Clear the port interrupts */
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT + (port_num << 8)), 0x0);
-
-	if (config_done == 0) {
-		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0);
-		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_B, 0);
-	}
-
-	/* Set the MAC Address */
-	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
-
-	if (config_done == 0)
-		titan_port_init(netdev, titan_ge_eth);
-
-	titan_ge_update_afx(titan_ge_eth);
-
-	/* Allocate the Tx ring now */
-	titan_ge_eth->tx_ring_skbs = 0;
-	titan_ge_eth->tx_ring_size = TITAN_GE_TX_QUEUE;
-
-	/* Allocate space in the SRAM for the descriptors */
-	titan_ge_eth->tx_desc_area = (titan_ge_tx_desc *)
-		(titan_ge_sram + TITAN_TX_RING_BYTES * port_num);
-	titan_ge_eth->tx_dma = TITAN_SRAM_BASE + TITAN_TX_RING_BYTES * port_num;
-
-	if (!titan_ge_eth->tx_desc_area) {
-		printk(KERN_ERR
-		       "%s: Cannot allocate Tx Ring (size %d bytes) for port %d\n",
-		       netdev->name, TITAN_TX_RING_BYTES, port_num);
-		return -ENOMEM;
-	}
-
-	memset(titan_ge_eth->tx_desc_area, 0, titan_ge_eth->tx_desc_area_size);
-
-	/* Now initialize the Tx descriptor ring */
-	titan_ge_init_tx_desc_ring(titan_ge_eth,
-				   titan_ge_eth->tx_ring_size,
-				   (unsigned long) titan_ge_eth->tx_desc_area,
-				   (unsigned long) titan_ge_eth->tx_dma);
-
-	/* Allocate the Rx ring now */
-	titan_ge_eth->rx_ring_size = TITAN_GE_RX_QUEUE;
-	titan_ge_eth->rx_ring_skbs = 0;
-
-	titan_ge_eth->rx_desc_area =
-		(titan_ge_rx_desc *)(titan_ge_sram + 0x1000 + TITAN_RX_RING_BYTES * port_num);
-
-	titan_ge_eth->rx_dma = TITAN_SRAM_BASE + 0x1000 + TITAN_RX_RING_BYTES * port_num;
-
-	if (!titan_ge_eth->rx_desc_area) {
-		printk(KERN_ERR "%s: Cannot allocate Rx Ring (size %d bytes)\n",
-		       netdev->name, TITAN_RX_RING_BYTES);
-
-		printk(KERN_ERR "%s: Freeing previously allocated TX queues...",
-		       netdev->name);
-
-		dma_free_coherent(device, titan_ge_eth->tx_desc_area_size,
-				    (void *) titan_ge_eth->tx_desc_area,
-				    titan_ge_eth->tx_dma);
-
-		return -ENOMEM;
-	}
-
-	memset(titan_ge_eth->rx_desc_area, 0, titan_ge_eth->rx_desc_area_size);
-
-	/* Now initialize the Rx ring */
-#ifdef TITAN_GE_JUMBO_FRAMES
-	if ((titan_ge_init_rx_desc_ring
-	    (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_JUMBO_BUFSIZE,
-	     (unsigned long) titan_ge_eth->rx_desc_area, 0,
-	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
-#else
-	if ((titan_ge_init_rx_desc_ring
-	     (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_STD_BUFSIZE,
-	      (unsigned long) titan_ge_eth->rx_desc_area, 0,
-	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
-#endif
-		panic("%s: Error initializing RX Ring\n", netdev->name);
-
-	/* Fill the Rx ring with the SKBs */
-	titan_ge_port_start(netdev, titan_ge_eth);
-
-	/*
-	 * Check if Interrupt Coalscing needs to be turned on. The
-	 * values specified in the register is multiplied by
-	 * (8 x 64 nanoseconds) to determine when an interrupt should
-	 * be sent to the CPU.
-	 */
-
-	if (TITAN_GE_TX_COAL) {
-		titan_ge_eth->tx_int_coal =
-		    titan_ge_tx_coal(TITAN_GE_TX_COAL, port_num);
-	}
-
-	err = titan_ge_mdio_read(port_num, TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
-	if (err == TITAN_GE_MDIO_ERROR) {
-		printk(KERN_ERR
-		       "Could not read PHY control register 0x11 \n");
-		return TITAN_ERROR;
-	}
-	if (!(phy_reg & 0x0400)) {
-		netif_carrier_off(netdev);
-		netif_stop_queue(netdev);
-		return TITAN_ERROR;
-	} else {
-		netif_carrier_on(netdev);
-		netif_start_queue(netdev);
-	}
-
-	return TITAN_OK;
-}
-
-/*
- * Queue the packet for Tx. Currently no support for zero copy,
- * checksum offload and Scatter Gather. The chip does support
- * Scatter Gather only. But, that wont help here since zero copy
- * requires support for Tx checksumming also.
- */
-int titan_ge_start_xmit(struct sk_buff *skb, struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned long flags;
-	struct net_device_stats *stats;
-//printk("titan_ge_start_xmit\n");
-
-	stats = &titan_ge_eth->stats;
-	spin_lock_irqsave(&titan_ge_eth->lock, flags);
-
-	if ((TITAN_GE_TX_QUEUE - titan_ge_eth->tx_ring_skbs) <=
-	    (skb_shinfo(skb)->nr_frags + 1)) {
-		netif_stop_queue(netdev);
-		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-		printk(KERN_ERR "Tx OOD \n");
-		return 1;
-	}
-
-	titan_ge_tx_queue(titan_ge_eth, skb);
-	titan_ge_eth->tx_ring_skbs++;
-
-	if (TITAN_GE_TX_QUEUE <= (titan_ge_eth->tx_ring_skbs + 4)) {
-		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-		titan_ge_free_tx_queue(titan_ge_eth);
-		spin_lock_irqsave(&titan_ge_eth->lock, flags);
-	}
-
-	stats->tx_bytes += skb->len;
-	stats->tx_packets++;
-
-	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-
-	netdev->trans_start = jiffies;
-
-	return 0;
-}
-
-/*
- * Actually does the Rx. Rx side checksumming supported.
- */
-static int titan_ge_rx(struct net_device *netdev, int port_num,
-			titan_ge_port_info * titan_ge_port,
-		       titan_ge_packet * packet)
-{
-	int rx_curr_desc, rx_used_desc;
-	volatile titan_ge_rx_desc *rx_desc;
-
-	rx_curr_desc = titan_ge_port->rx_curr_desc_q;
-	rx_used_desc = titan_ge_port->rx_used_desc_q;
-
-	if (((rx_curr_desc + 1) % TITAN_GE_RX_QUEUE) == rx_used_desc)
-		return TITAN_ERROR;
-
-	rx_desc = &(titan_ge_port->rx_desc_area[rx_curr_desc]);
-
-	if (rx_desc->cmd_sts & TITAN_GE_RX_BUFFER_OWNED)
-		return TITAN_ERROR;
-
-	packet->skb = titan_ge_port->rx_skb[rx_curr_desc];
-	packet->len = (rx_desc->cmd_sts & 0x7fff);
-
-	/*
-	 * At this point, we dont know if the checksumming
-	 * actually helps relieve CPU. So, keep it for
-	 * port 0 only
-	 */
-	packet->checksum = ntohs((rx_desc->buffer & 0xffff0000) >> 16);
-	packet->cmd_sts = rx_desc->cmd_sts;
-
-	titan_ge_port->rx_curr_desc_q = (rx_curr_desc + 1) % TITAN_GE_RX_QUEUE;
-
-	/* Prefetch the next descriptor */
-	prefetch((const void *)
-	       &titan_ge_port->rx_desc_area[titan_ge_port->rx_curr_desc_q + 1]);
-
-	return TITAN_OK;
-}
-
-/*
- * Free the Tx queue of the used SKBs
- */
-static int titan_ge_free_tx_queue(titan_ge_port_info *titan_ge_eth)
-{
-	unsigned long flags;
-
-	/* Take the lock */
-	spin_lock_irqsave(&(titan_ge_eth->lock), flags);
-
-	while (titan_ge_return_tx_desc(titan_ge_eth, titan_ge_eth->port_num) == 0)
-		if (titan_ge_eth->tx_ring_skbs != 1)
-			titan_ge_eth->tx_ring_skbs--;
-
-	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-
-	return TITAN_OK;
-}
-
-/*
- * Threshold beyond which we do the cleaning of
- * Tx queue and new allocation for the Rx
- * queue
- */
-#define	TX_THRESHOLD	4
-#define	RX_THRESHOLD	10
-
-/*
- * Receive the packets and send it to the kernel.
- */
-static int titan_ge_receive_queue(struct net_device *netdev, unsigned int max)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	titan_ge_packet packet;
-	struct net_device_stats *stats;
-	struct sk_buff *skb;
-	unsigned long received_packets = 0;
-	unsigned int ack;
-
-	stats = &titan_ge_eth->stats;
-
-	while ((--max)
-	       && (titan_ge_rx(netdev, port_num, titan_ge_eth, &packet) == TITAN_OK)) {
-		skb = (struct sk_buff *) packet.skb;
-
-		titan_ge_eth->rx_ring_skbs--;
-
-		if (--titan_ge_eth->rx_work_limit < 0)
-			break;
-		received_packets++;
-
-		stats->rx_packets++;
-		stats->rx_bytes += packet.len;
-
-		if ((packet.cmd_sts & TITAN_GE_RX_PERR) ||
-			(packet.cmd_sts & TITAN_GE_RX_OVERFLOW_ERROR) ||
-			(packet.cmd_sts & TITAN_GE_RX_TRUNC) ||
-			(packet.cmd_sts & TITAN_GE_RX_CRC_ERROR)) {
-				stats->rx_dropped++;
-				dev_kfree_skb_any(skb);
-
-				continue;
-		}
-		/*
-		 * Either support fast path or slow path. Decision
-		 * making can really slow down the performance. The
-		 * idea is to cut down the number of checks and improve
-		 * the fastpath.
-		 */
-
-		skb_put(skb, packet.len - 2);
-
-		/*
-		 * Increment data pointer by two since thats where
-		 * the MAC starts
-		 */
-		skb_reserve(skb, 2);
-		skb->protocol = eth_type_trans(skb, netdev);
-		netif_receive_skb(skb);
-
-		if (titan_ge_eth->rx_threshold > RX_THRESHOLD) {
-			ack = titan_ge_rx_task(netdev, titan_ge_eth);
-			TITAN_GE_WRITE((0x5048 + (port_num << 8)), ack);
-			titan_ge_eth->rx_threshold = 0;
-		} else
-			titan_ge_eth->rx_threshold++;
-
-		if (titan_ge_eth->tx_threshold > TX_THRESHOLD) {
-			titan_ge_eth->tx_threshold = 0;
-			titan_ge_free_tx_queue(titan_ge_eth);
-		}
-		else
-			titan_ge_eth->tx_threshold++;
-
-	}
-	return received_packets;
-}
-
-
-/*
- * Enable the Rx side interrupts
- */
-static void titan_ge_enable_int(unsigned int port_num,
-			titan_ge_port_info *titan_ge_eth,
-			struct net_device *netdev)
-{
-	unsigned long reg_data = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
-
-	if (port_num == 0)
-		reg_data |= 0x3;
-	if (port_num == 1)
-		reg_data |= 0x300;
-	if (port_num == 2)
-		reg_data |= 0x30000;
-
-	/* Re-enable interrupts */
-	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data);
-}
-
-/*
- * Main function to handle the polling for Rx side NAPI.
- * Receive interrupts have been disabled at this point.
- * The poll schedules the transmit followed by receive.
- */
-static int titan_ge_poll(struct net_device *netdev, int *budget)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	int port_num = titan_ge_eth->port_num;
-	int work_done = 0;
-	unsigned long flags, status;
-
-	titan_ge_eth->rx_work_limit = *budget;
-	if (titan_ge_eth->rx_work_limit > netdev->quota)
-		titan_ge_eth->rx_work_limit = netdev->quota;
-
-	do {
-		/* Do the transmit cleaning work here */
-		titan_ge_free_tx_queue(titan_ge_eth);
-
-		/* Ack the Rx interrupts */
-		if (port_num == 0)
-			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x3);
-		if (port_num == 1)
-			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x300);
-		if (port_num == 2)
-			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x30000);
-
-		work_done += titan_ge_receive_queue(netdev, 0);
-
-		/* Out of quota and there is work to be done */
-		if (titan_ge_eth->rx_work_limit < 0)
-			goto not_done;
-
-		/* Receive alloc_skb could lead to OOM */
-		if (oom_flag == 1) {
-			oom_flag = 0;
-			goto oom;
-		}
-
-		status = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
-	} while (status & 0x30300);
-
-	/* If we are here, then no more interrupts to process */
-	goto done;
-
-not_done:
-	*budget -= work_done;
-	netdev->quota -= work_done;
-	return 1;
-
-oom:
-	printk(KERN_ERR "OOM \n");
-	netif_rx_complete(netdev);
-	return 0;
-
-done:
-	/*
-	 * No more packets on the poll list. Turn the interrupts
-	 * back on and we should be able to catch the new
-	 * packets in the interrupt handler
-	 */
-	if (!work_done)
-		work_done = 1;
-
-	*budget -= work_done;
-	netdev->quota -= work_done;
-
-	spin_lock_irqsave(&titan_ge_eth->lock, flags);
-
-	/* Remove us from the poll list */
-	netif_rx_complete(netdev);
-
-	/* Re-enable interrupts */
-	titan_ge_enable_int(port_num, titan_ge_eth, netdev);
-
-	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
-
-	return 0;
-}
-
-/*
- * Close the network device
- */
-int titan_ge_stop(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-
-	spin_lock_irq(&(titan_ge_eth->lock));
-	titan_ge_eth_stop(netdev);
-	free_irq(netdev->irq, netdev);
-	spin_unlock_irq(&titan_ge_eth->lock);
-
-	return TITAN_OK;
-}
-
-/*
- * Free the Tx ring
- */
-static void titan_ge_free_tx_rings(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	unsigned int curr;
-	unsigned long reg_data;
-
-	/* Stop the Tx DMA */
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG +
-				(port_num << 8));
-	reg_data |= 0xc0000000;
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
-			(port_num << 8)), reg_data);
-
-	/* Disable the TMAC */
-	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
-				(port_num << 12));
-	reg_data &= ~(0x00000001);
-	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
-			(port_num << 12)), reg_data);
-
-	for (curr = 0;
-	     (titan_ge_eth->tx_ring_skbs) && (curr < TITAN_GE_TX_QUEUE);
-	     curr++) {
-		if (titan_ge_eth->tx_skb[curr]) {
-			dev_kfree_skb(titan_ge_eth->tx_skb[curr]);
-			titan_ge_eth->tx_ring_skbs--;
-		}
-	}
-
-	if (titan_ge_eth->tx_ring_skbs != 0)
-		printk
-		    ("%s: Error on Tx descriptor free - could not free %d"
-		     " descriptors\n", netdev->name,
-		     titan_ge_eth->tx_ring_skbs);
-
-#ifndef TITAN_RX_RING_IN_SRAM
-	dma_free_coherent(&titan_ge_device[port_num]->dev,
-			  titan_ge_eth->tx_desc_area_size,
-			  (void *) titan_ge_eth->tx_desc_area,
-			  titan_ge_eth->tx_dma);
-#endif
-}
-
-/*
- * Free the Rx ring
- */
-static void titan_ge_free_rx_rings(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	unsigned int curr;
-	unsigned long reg_data;
-
-	/* Stop the Rx DMA */
-	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG +
-				(port_num << 8));
-	reg_data |= 0x000c0000;
-	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
-			(port_num << 8)), reg_data);
-
-	/* Disable the RMAC */
-	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
-				(port_num << 12));
-	reg_data &= ~(0x00000001);
-	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
-			(port_num << 12)), reg_data);
-
-	for (curr = 0;
-	     titan_ge_eth->rx_ring_skbs && (curr < TITAN_GE_RX_QUEUE);
-	     curr++) {
-		if (titan_ge_eth->rx_skb[curr]) {
-			dev_kfree_skb(titan_ge_eth->rx_skb[curr]);
-			titan_ge_eth->rx_ring_skbs--;
-		}
-	}
-
-	if (titan_ge_eth->rx_ring_skbs != 0)
-		printk(KERN_ERR
-		       "%s: Error in freeing Rx Ring. %d skb's still"
-		       " stuck in RX Ring - ignoring them\n", netdev->name,
-		       titan_ge_eth->rx_ring_skbs);
-
-#ifndef TITAN_RX_RING_IN_SRAM
-	dma_free_coherent(&titan_ge_device[port_num]->dev,
-			  titan_ge_eth->rx_desc_area_size,
-			  (void *) titan_ge_eth->rx_desc_area,
-			  titan_ge_eth->rx_dma);
-#endif
-}
-
-/*
- * Actually does the stop of the Ethernet device
- */
-static void titan_ge_eth_stop(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-
-	netif_stop_queue(netdev);
-
-	titan_ge_port_reset(titan_ge_eth->port_num);
-
-	titan_ge_free_tx_rings(netdev);
-	titan_ge_free_rx_rings(netdev);
-
-	/* Disable the Tx and Rx Interrupts for all channels */
-	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, 0x0);
-}
-
-/*
- * Update the MAC address. Note that we have to write the
- * address in three station registers, 16 bits each. And this
- * has to be done for TMAC and RMAC
- */
-static void titan_ge_update_mac_address(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-	unsigned int port_num = titan_ge_eth->port_num;
-	u8 p_addr[6];
-
-	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
-	memcpy(p_addr, netdev->dev_addr, 6);
-
-	/* Update the Address Filtering Match tables */
-	titan_ge_update_afx(titan_ge_eth);
-
-	printk("Station MAC : %d %d %d %d %d %d  \n",
-		p_addr[5], p_addr[4], p_addr[3],
-		p_addr[2], p_addr[1], p_addr[0]);
-
-	/* Set the MAC address here for TMAC and RMAC */
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port_num << 12)),
-		       ((p_addr[5] << 8) | p_addr[4]));
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port_num << 12)),
-		       ((p_addr[3] << 8) | p_addr[2]));
-	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port_num << 12)),
-		       ((p_addr[1] << 8) | p_addr[0]));
-
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port_num << 12)),
-		       ((p_addr[5] << 8) | p_addr[4]));
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port_num << 12)),
-		       ((p_addr[3] << 8) | p_addr[2]));
-	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port_num << 12)),
-		       ((p_addr[1] << 8) | p_addr[0]));
-}
-
-/*
- * Set the MAC address of the Ethernet device
- */
-static int titan_ge_set_mac_address(struct net_device *dev, void *addr)
-{
-	titan_ge_port_info *tp = netdev_priv(dev);
-	struct sockaddr *sa = addr;
-
-	memcpy(dev->dev_addr, sa->sa_data, dev->addr_len);
-
-	spin_lock_irq(&tp->lock);
-	titan_ge_update_mac_address(dev);
-	spin_unlock_irq(&tp->lock);
-
-	return 0;
-}
-
-/*
- * Get the Ethernet device stats
- */
-static struct net_device_stats *titan_ge_get_stats(struct net_device *netdev)
-{
-	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
-
-	return &titan_ge_eth->stats;
-}
-
-/*
- * Initialize the Rx descriptor ring for the Titan Ge
- */
-static int titan_ge_init_rx_desc_ring(titan_ge_port_info * titan_eth_port,
-				      int rx_desc_num,
-				      int rx_buff_size,
-				      unsigned long rx_desc_base_addr,
-				      unsigned long rx_buff_base_addr,
-				      unsigned long rx_dma)
-{
-	volatile titan_ge_rx_desc *rx_desc;
-	unsigned long buffer_addr;
-	int index;
-	unsigned long titan_ge_rx_desc_bus = rx_dma;
-
-	buffer_addr = rx_buff_base_addr;
-	rx_desc = (titan_ge_rx_desc *) rx_desc_base_addr;
-
-	/* Check alignment */
-	if (rx_buff_base_addr & 0xF)
-		return 0;
-
-	/* Check Rx buffer size */
-	if ((rx_buff_size < 8) || (rx_buff_size > TITAN_GE_MAX_RX_BUFFER))
-		return 0;
-
-	/* 64-bit alignment
-	if ((rx_buff_base_addr + rx_buff_size) & 0x7)
-		return 0; */
-
-	/* Initialize the Rx desc ring */
-	for (index = 0; index < rx_desc_num; index++) {
-		titan_ge_rx_desc_bus += sizeof(titan_ge_rx_desc);
-		rx_desc[index].cmd_sts = 0;
-		rx_desc[index].buffer_addr = buffer_addr;
-		titan_eth_port->rx_skb[index] = NULL;
-		buffer_addr += rx_buff_size;
-	}
-
-	titan_eth_port->rx_curr_desc_q = 0;
-	titan_eth_port->rx_used_desc_q = 0;
-
-	titan_eth_port->rx_desc_area = (titan_ge_rx_desc *) rx_desc_base_addr;
-	titan_eth_port->rx_desc_area_size =
-	    rx_desc_num * sizeof(titan_ge_rx_desc);
-
-	titan_eth_port->rx_dma = rx_dma;
-
-	return TITAN_OK;
-}
-
-/*
- * Initialize the Tx descriptor ring. Descriptors in the SRAM
- */
-static int titan_ge_init_tx_desc_ring(titan_ge_port_info * titan_ge_port,
-				      int tx_desc_num,
-				      unsigned long tx_desc_base_addr,
-				      unsigned long tx_dma)
-{
-	titan_ge_tx_desc *tx_desc;
-	int index;
-	unsigned long titan_ge_tx_desc_bus = tx_dma;
-
-	if (tx_desc_base_addr & 0xF)
-		return 0;
-
-	tx_desc = (titan_ge_tx_desc *) tx_desc_base_addr;
-
-	for (index = 0; index < tx_desc_num; index++) {
-		titan_ge_port->tx_dma_array[index] =
-		    (dma_addr_t) titan_ge_tx_desc_bus;
-		titan_ge_tx_desc_bus += sizeof(titan_ge_tx_desc);
-		tx_desc[index].cmd_sts = 0x0000;
-		tx_desc[index].buffer_len = 0;
-		tx_desc[index].buffer_addr = 0x00000000;
-		titan_ge_port->tx_skb[index] = NULL;
-	}
-
-	titan_ge_port->tx_curr_desc_q = 0;
-	titan_ge_port->tx_used_desc_q = 0;
-
-	titan_ge_port->tx_desc_area = (titan_ge_tx_desc *) tx_desc_base_addr;
-	titan_ge_port->tx_desc_area_size =
-	    tx_desc_num * sizeof(titan_ge_tx_desc);
-
-	titan_ge_port->tx_dma = tx_dma;
-	return TITAN_OK;
-}
-
-/*
- * Initialize the device as an Ethernet device
- */
-static int __init titan_ge_probe(struct device *device)
-{
-	titan_ge_port_info *titan_ge_eth;
-	struct net_device *netdev;
-	int port = to_platform_device(device)->id;
-	int err;
-
-	netdev = alloc_etherdev(sizeof(titan_ge_port_info));
-	if (!netdev) {
-		err = -ENODEV;
-		goto out;
-	}
-
-	netdev->open = titan_ge_open;
-	netdev->stop = titan_ge_stop;
-	netdev->hard_start_xmit = titan_ge_start_xmit;
-	netdev->get_stats = titan_ge_get_stats;
-	netdev->set_multicast_list = titan_ge_set_multi;
-	netdev->set_mac_address = titan_ge_set_mac_address;
-
-	/* Tx timeout */
-	netdev->tx_timeout = titan_ge_tx_timeout;
-	netdev->watchdog_timeo = 2 * HZ;
-
-	/* Set these to very high values */
-	netdev->poll = titan_ge_poll;
-	netdev->weight = 64;
-
-	netdev->tx_queue_len = TITAN_GE_TX_QUEUE;
-	netif_carrier_off(netdev);
-	netdev->base_addr = 0;
-
-	netdev->change_mtu = titan_ge_change_mtu;
-
-	titan_ge_eth = netdev_priv(netdev);
-	/* Allocation of memory for the driver structures */
-
-	titan_ge_eth->port_num = port;
-
-	/* Configure the Tx timeout handler */
-	INIT_WORK(&titan_ge_eth->tx_timeout_task,
-		  (void (*)(void *)) titan_ge_tx_timeout_task, netdev);
-
-	spin_lock_init(&titan_ge_eth->lock);
-
-	/* set MAC addresses */
-	memcpy(netdev->dev_addr, titan_ge_mac_addr_base, 6);
-	netdev->dev_addr[5] += port;
-
-	err = register_netdev(netdev);
-
-	if (err)
-		goto out_free_netdev;
-
-	printk(KERN_NOTICE
-	       "%s: port %d with MAC address %02x:%02x:%02x:%02x:%02x:%02x\n",
-	       netdev->name, port, netdev->dev_addr[0],
-	       netdev->dev_addr[1], netdev->dev_addr[2],
-	       netdev->dev_addr[3], netdev->dev_addr[4],
-	       netdev->dev_addr[5]);
-
-	printk(KERN_NOTICE "Rx NAPI supported, Tx Coalescing ON \n");
-
-	return 0;
-
-out_free_netdev:
-	kfree(netdev);
-
-out:
-	return err;
-}
-
-static void __devexit titan_device_remove(struct device *device)
-{
-}
-
-/*
- * Reset the Ethernet port
- */
-static void titan_ge_port_reset(unsigned int port_num)
-{
-	unsigned int reg_data;
-
-	/* Stop the Tx port activity */
-	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
-				(port_num << 12));
-	reg_data &= ~(0x0001);
-	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
-			(port_num << 12)), reg_data);
-
-	/* Stop the Rx port activity */
-	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
-				(port_num << 12));
-	reg_data &= ~(0x0001);
-	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
-			(port_num << 12)), reg_data);
-
-	return;
-}
-
-/*
- * Return the Tx desc after use by the XDMA
- */
-static int titan_ge_return_tx_desc(titan_ge_port_info * titan_ge_eth, int port)
-{
-	int tx_desc_used;
-	struct sk_buff *skb;
-
-	tx_desc_used = titan_ge_eth->tx_used_desc_q;
-
-	/* return right away */
-	if (tx_desc_used == titan_ge_eth->tx_curr_desc_q)
-		return TITAN_ERROR;
-
-	/* Now the critical stuff */
-	skb = titan_ge_eth->tx_skb[tx_desc_used];
-
-	dev_kfree_skb_any(skb);
-
-	titan_ge_eth->tx_skb[tx_desc_used] = NULL;
-	titan_ge_eth->tx_used_desc_q =
-	    (tx_desc_used + 1) % TITAN_GE_TX_QUEUE;
-
-	return 0;
-}
-
-/*
- * Coalescing for the Tx path
- */
-static unsigned long titan_ge_tx_coal(unsigned long delay, int port)
-{
-	unsigned long rx_delay;
-
-	rx_delay = TITAN_GE_READ(TITAN_GE_INT_COALESCING);
-	delay = (delay << 16) | rx_delay;
-
-	TITAN_GE_WRITE(TITAN_GE_INT_COALESCING, delay);
-	TITAN_GE_WRITE(0x5038, delay);
-
-	return delay;
-}
-
-static struct device_driver titan_soc_driver = {
-	.name   = titan_string,
-	.bus    = &platform_bus_type,
-	.probe  = titan_ge_probe,
-	.remove = __devexit_p(titan_device_remove),
-};
-
-static void titan_platform_release (struct device *device)
-{
-	struct platform_device *pldev;
-
-	/* free device */
-	pldev = to_platform_device (device);
-	kfree (pldev);
-}
-
-/*
- * Register the Titan GE with the kernel
- */
-static int __init titan_ge_init_module(void)
-{
-	struct platform_device *pldev;
-	unsigned int version, device;
-	int i;
-
-	printk(KERN_NOTICE
-	       "PMC-Sierra TITAN 10/100/1000 Ethernet Driver \n");
-
-	titan_ge_base = (unsigned long) ioremap(TITAN_GE_BASE, TITAN_GE_SIZE);
-	if (!titan_ge_base) {
-		printk("Mapping Titan GE failed\n");
-		goto out;
-	}
-
-	device = TITAN_GE_READ(TITAN_GE_DEVICE_ID);
-	version = (device & 0x000f0000) >> 16;
-	device &= 0x0000ffff;
-
-	printk(KERN_NOTICE "Device Id : %x,  Version : %x \n", device, version);
-
-#ifdef TITAN_RX_RING_IN_SRAM
-	titan_ge_sram = (unsigned long) ioremap(TITAN_SRAM_BASE,
-						TITAN_SRAM_SIZE);
-	if (!titan_ge_sram) {
-		printk("Mapping Titan SRAM failed\n");
-		goto out_unmap_ge;
-	}
-#endif
-
-	if (driver_register(&titan_soc_driver)) {
-		printk(KERN_ERR "Driver registration failed\n");
-		goto out_unmap_sram;
-	}
-
-	for (i = 0; i < 3; i++) {
-		titan_ge_device[i] = NULL;
-
-		if (!(pldev = kmalloc (sizeof (*pldev), GFP_KERNEL)))
-			continue;
-
-		memset (pldev, 0, sizeof (*pldev));
-		pldev->name		= titan_string;
-		pldev->id		= i;
-		pldev->dev.release	= titan_platform_release;
-		titan_ge_device[i]	= pldev;
-
-		if (platform_device_register (pldev)) {
-			kfree (pldev);
-			titan_ge_device[i] = NULL;
-			continue;
-		}
-
-		if (!pldev->dev.driver) {
-			/*
-			 * The driver was not bound to this device, there was
-			 * no hardware at this address. Unregister it, as the
-			 * release fuction will take care of freeing the
-			 * allocated structure
-			 */
-			titan_ge_device[i] = NULL;
-			platform_device_unregister (pldev);
-		}
-	}
-
-	return 0;
-
-out_unmap_sram:
-	iounmap((void *)titan_ge_sram);
-
-out_unmap_ge:
-	iounmap((void *)titan_ge_base);
-
-out:
-	return -ENOMEM;
-}
-
-/*
- * Unregister the Titan GE from the kernel
- */
-static void __exit titan_ge_cleanup_module(void)
-{
-	int i;
-
-	driver_unregister(&titan_soc_driver);
-
-	for (i = 0; i < 3; i++) {
-		if (titan_ge_device[i]) {
-			platform_device_unregister (titan_ge_device[i]);
-			titan_ge_device[i] = NULL;
-		}
-	}
-
-	iounmap((void *)titan_ge_sram);
-	iounmap((void *)titan_ge_base);
-}
-
-MODULE_AUTHOR("Manish Lachwani <lachwani@pmc-sierra.com>");
-MODULE_DESCRIPTION("Titan GE Ethernet driver");
-MODULE_LICENSE("GPL");
-
-module_init(titan_ge_init_module);
-module_exit(titan_ge_cleanup_module);
diff -Naur linux-3.5.4/drivers/net/ethernet/pmc-sierra/titan_ge.h linux-2012.09/drivers/net/ethernet/pmc-sierra/titan_ge.h
--- linux-3.5.4/drivers/net/ethernet/pmc-sierra/titan_ge.h	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/drivers/net/ethernet/pmc-sierra/titan_ge.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,415 +0,0 @@
-#ifndef _TITAN_GE_H_
-#define _TITAN_GE_H_
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/spinlock.h>
-#include <asm/byteorder.h>
-
-/*
- * These functions should be later moved to a more generic location since there
- * will be others accessing it also
- */
-
-/*
- * This is the way it works: LKB5 Base is at 0x0128. TITAN_BASE is defined in
- * include/asm/titan_dep.h. TITAN_GE_BASE is the value in the TITAN_GE_LKB5
- * register.
- */
-
-#define	TITAN_GE_BASE	0xfe000000UL
-#define	TITAN_GE_SIZE	0x10000UL
-
-extern unsigned long titan_ge_base;
-
-#define	TITAN_GE_WRITE(offset, data) \
-		*(volatile u32 *)(titan_ge_base + (offset)) = (data)
-
-#define TITAN_GE_READ(offset) *(volatile u32 *)(titan_ge_base + (offset))
-
-#ifndef msec_delay
-#define msec_delay(x)   do { if(in_interrupt()) { \
-				/* Don't mdelay in interrupt context! */ \
-				BUG(); \
-			} else { \
-				set_current_state(TASK_UNINTERRUPTIBLE); \
-				schedule_timeout((x * HZ)/1000); \
-			} } while(0)
-#endif
-
-#define TITAN_GE_PORT_0
-
-#define	TITAN_SRAM_BASE		((OCD_READ(RM9000x2_OCD_LKB13) & ~1) << 4)
-#define	TITAN_SRAM_SIZE		0x2000UL
-
-/*
- * We may need these constants
- */
-#define TITAN_BIT0    0x00000001
-#define TITAN_BIT1    0x00000002
-#define TITAN_BIT2    0x00000004
-#define TITAN_BIT3    0x00000008
-#define TITAN_BIT4    0x00000010
-#define TITAN_BIT5    0x00000020
-#define TITAN_BIT6    0x00000040
-#define TITAN_BIT7    0x00000080
-#define TITAN_BIT8    0x00000100
-#define TITAN_BIT9    0x00000200
-#define TITAN_BIT10   0x00000400
-#define TITAN_BIT11   0x00000800
-#define TITAN_BIT12   0x00001000
-#define TITAN_BIT13   0x00002000
-#define TITAN_BIT14   0x00004000
-#define TITAN_BIT15   0x00008000
-#define TITAN_BIT16   0x00010000
-#define TITAN_BIT17   0x00020000
-#define TITAN_BIT18   0x00040000
-#define TITAN_BIT19   0x00080000
-#define TITAN_BIT20   0x00100000
-#define TITAN_BIT21   0x00200000
-#define TITAN_BIT22   0x00400000
-#define TITAN_BIT23   0x00800000
-#define TITAN_BIT24   0x01000000
-#define TITAN_BIT25   0x02000000
-#define TITAN_BIT26   0x04000000
-#define TITAN_BIT27   0x08000000
-#define TITAN_BIT28   0x10000000
-#define TITAN_BIT29   0x20000000
-#define TITAN_BIT30   0x40000000
-#define TITAN_BIT31   0x80000000
-
-/* Flow Control */
-#define	TITAN_GE_FC_NONE	0x0
-#define	TITAN_GE_FC_FULL	0x1
-#define	TITAN_GE_FC_TX_PAUSE	0x2
-#define	TITAN_GE_FC_RX_PAUSE	0x3
-
-/* Duplex Settings */
-#define	TITAN_GE_FULL_DUPLEX	0x1
-#define	TITAN_GE_HALF_DUPLEX	0x2
-
-/* Speed settings */
-#define	TITAN_GE_SPEED_1000	0x1
-#define	TITAN_GE_SPEED_100	0x2
-#define	TITAN_GE_SPEED_10	0x3
-
-/* Debugging info only */
-#undef TITAN_DEBUG
-
-/* Keep the rings in the Titan's SSRAM */
-#define TITAN_RX_RING_IN_SRAM
-
-#ifdef CONFIG_64BIT
-#define	TITAN_GE_IE_MASK	0xfffffffffb001b64
-#define	TITAN_GE_IE_STATUS	0xfffffffffb001b60
-#else
-#define	TITAN_GE_IE_MASK	0xfb001b64
-#define	TITAN_GE_IE_STATUS	0xfb001b60
-#endif
-
-/* Support for Jumbo Frames */
-#undef TITAN_GE_JUMBO_FRAMES
-
-/* Rx buffer size */
-#ifdef TITAN_GE_JUMBO_FRAMES
-#define	TITAN_GE_JUMBO_BUFSIZE	9080
-#else
-#define	TITAN_GE_STD_BUFSIZE	1580
-#endif
-
-/*
- * Tx and Rx Interrupt Coalescing parameter. These values are
- * for 1 Ghz processor. Rx coalescing can be taken care of
- * by NAPI. NAPI is adaptive and hence useful. Tx coalescing
- * is not adaptive. Hence, these values need to be adjusted
- * based on load, CPU speed etc.
- */
-#define	TITAN_GE_RX_COAL	150
-#define	TITAN_GE_TX_COAL	300
-
-#if defined(__BIG_ENDIAN)
-
-/* Define the Rx descriptor */
-typedef struct eth_rx_desc {
-	u32     reserved;	/* Unused 		*/
-	u32     buffer_addr;	/* CPU buffer address 	*/
-	u32	cmd_sts;	/* Command and Status	*/
-	u32	buffer;		/* XDMA buffer address	*/
-} titan_ge_rx_desc;
-
-/* Define the Tx descriptor */
-typedef struct eth_tx_desc {
-	u16     cmd_sts;	/* Command, Status and Buffer count */
-	u16	buffer_len;	/* Length of the buffer	*/
-	u32     buffer_addr;	/* Physical address of the buffer */
-} titan_ge_tx_desc;
-
-#elif defined(__LITTLE_ENDIAN)
-
-/* Define the Rx descriptor */
-typedef struct eth_rx_desc {
-	u32	buffer_addr;	/* CPU buffer address   */
-	u32	reserved;	/* Unused               */
-	u32	buffer;		/* XDMA buffer address  */
-	u32	cmd_sts;	/* Command and Status   */
-} titan_ge_rx_desc;
-
-/* Define the Tx descriptor */
-typedef struct eth_tx_desc {
-	u32     buffer_addr;	/* Physical address of the buffer */
-	u16     buffer_len;     /* Length of the buffer */
-	u16     cmd_sts;        /* Command, Status and Buffer count */
-} titan_ge_tx_desc;
-#endif
-
-/* Default Tx Queue Size */
-#define	TITAN_GE_TX_QUEUE	128
-#define TITAN_TX_RING_BYTES	(TITAN_GE_TX_QUEUE * sizeof(struct eth_tx_desc))
-
-/* Default Rx Queue Size */
-#define	TITAN_GE_RX_QUEUE	64
-#define TITAN_RX_RING_BYTES	(TITAN_GE_RX_QUEUE * sizeof(struct eth_rx_desc))
-
-/* Packet Structure */
-typedef struct _pkt_info {
-	unsigned int           len;
-	unsigned int            cmd_sts;
-	unsigned int            buffer;
-	struct sk_buff          *skb;
-	unsigned int		checksum;
-} titan_ge_packet;
-
-
-#define	PHYS_CNT	3
-
-/* Titan Port specific data structure */
-typedef struct _eth_port_ctrl {
-	unsigned int		port_num;
-	u8			port_mac_addr[6];
-
-	/* Rx descriptor pointers */
-	int 			rx_curr_desc_q, rx_used_desc_q;
-
-	/* Tx descriptor pointers */
-	int 			tx_curr_desc_q, tx_used_desc_q;
-
-	/* Rx descriptor area */
-	volatile titan_ge_rx_desc	*rx_desc_area;
-	unsigned int			rx_desc_area_size;
-	struct sk_buff*			rx_skb[TITAN_GE_RX_QUEUE];
-
-	/* Tx Descriptor area */
-	volatile titan_ge_tx_desc	*tx_desc_area;
-	unsigned int                    tx_desc_area_size;
-	struct sk_buff*                 tx_skb[TITAN_GE_TX_QUEUE];
-
-	/* Timeout task */
-	struct work_struct		tx_timeout_task;
-
-	/* DMA structures and handles */
-	dma_addr_t			tx_dma;
-	dma_addr_t			rx_dma;
-	dma_addr_t			tx_dma_array[TITAN_GE_TX_QUEUE];
-
-	/* Device lock */
-	spinlock_t			lock;
-
-	unsigned int			tx_ring_skbs;
-	unsigned int			rx_ring_size;
-	unsigned int			tx_ring_size;
-	unsigned int			rx_ring_skbs;
-
-	struct net_device_stats		stats;
-
-	/* Tx and Rx coalescing */
-	unsigned long			rx_int_coal;
-	unsigned long			tx_int_coal;
-
-	/* Threshold for replenishing the Rx and Tx rings */
-	unsigned int			tx_threshold;
-	unsigned int			rx_threshold;
-
-	/* NAPI work limit */
-	unsigned int			rx_work_limit;
-} titan_ge_port_info;
-
-/* Titan specific constants */
-#define	TITAN_ETH_PORT_IRQ		3
-
-/* Max Rx buffer */
-#define	TITAN_GE_MAX_RX_BUFFER		65536
-
-/* Tx and Rx Error */
-#define	TITAN_GE_ERROR
-
-/* Rx Descriptor Command and Status */
-
-#define	TITAN_GE_RX_CRC_ERROR		TITAN_BIT27	/* crc error */
-#define	TITAN_GE_RX_OVERFLOW_ERROR	TITAN_BIT15	/* overflow */
-#define TITAN_GE_RX_BUFFER_OWNED	TITAN_BIT21	/* buffer ownership */
-#define	TITAN_GE_RX_STP			TITAN_BIT31	/* start of packet */
-#define	TITAN_GE_RX_BAM			TITAN_BIT30	/* broadcast address match */
-#define TITAN_GE_RX_PAM			TITAN_BIT28	/* physical address match */
-#define TITAN_GE_RX_LAFM		TITAN_BIT29	/* logical address filter match */
-#define TITAN_GE_RX_VLAN		TITAN_BIT26	/* virtual lans */
-#define TITAN_GE_RX_PERR		TITAN_BIT19	/* packet error */
-#define TITAN_GE_RX_TRUNC		TITAN_BIT20	/* packet size greater than 32 buffers */
-
-/* Tx Descriptor Command */
-#define	TITAN_GE_TX_BUFFER_OWNED	TITAN_BIT5	/* buffer ownership */
-#define	TITAN_GE_TX_ENABLE_INTERRUPT	TITAN_BIT15	/* Interrupt Enable */
-
-/* Return Status */
-#define	TITAN_OK	0x1	/* Good Status */
-#define	TITAN_ERROR	0x2	/* Error Status */
-
-/* MIB specific register offset */
-#define TITAN_GE_MSTATX_STATS_BASE_LOW       0x0800  /* MSTATX COUNTL[15:0] */
-#define TITAN_GE_MSTATX_STATS_BASE_MID       0x0804  /* MSTATX COUNTM[15:0] */
-#define TITAN_GE_MSTATX_STATS_BASE_HI        0x0808  /* MSTATX COUNTH[7:0] */
-#define TITAN_GE_MSTATX_CONTROL              0x0828  /* MSTATX Control */
-#define TITAN_GE_MSTATX_VARIABLE_SELECT      0x082C  /* MSTATX Variable Select */
-
-/* MIB counter offsets, add to the TITAN_GE_MSTATX_STATS_BASE_XXX */
-#define TITAN_GE_MSTATX_RXFRAMESOK                   0x0040
-#define TITAN_GE_MSTATX_RXOCTETSOK                   0x0050
-#define TITAN_GE_MSTATX_RXFRAMES                     0x0060
-#define TITAN_GE_MSTATX_RXOCTETS                     0x0070
-#define TITAN_GE_MSTATX_RXUNICASTFRAMESOK            0x0080
-#define TITAN_GE_MSTATX_RXBROADCASTFRAMESOK          0x0090
-#define TITAN_GE_MSTATX_RXMULTICASTFRAMESOK          0x00A0
-#define TITAN_GE_MSTATX_RXTAGGEDFRAMESOK             0x00B0
-#define TITAN_GE_MSTATX_RXMACPAUSECONTROLFRAMESOK    0x00C0
-#define TITAN_GE_MSTATX_RXMACCONTROLFRAMESOK         0x00D0
-#define TITAN_GE_MSTATX_RXFCSERROR                   0x00E0
-#define TITAN_GE_MSTATX_RXALIGNMENTERROR             0x00F0
-#define TITAN_GE_MSTATX_RXSYMBOLERROR                0x0100
-#define TITAN_GE_MSTATX_RXLAYER1ERROR                0x0110
-#define TITAN_GE_MSTATX_RXINRANGELENGTHERROR         0x0120
-#define TITAN_GE_MSTATX_RXLONGLENGTHERROR            0x0130
-#define TITAN_GE_MSTATX_RXLONGLENGTHCRCERROR         0x0140
-#define TITAN_GE_MSTATX_RXSHORTLENGTHERROR           0x0150
-#define TITAN_GE_MSTATX_RXSHORTLLENGTHCRCERROR       0x0160
-#define TITAN_GE_MSTATX_RXFRAMES64OCTETS             0x0170
-#define TITAN_GE_MSTATX_RXFRAMES65TO127OCTETS        0x0180
-#define TITAN_GE_MSTATX_RXFRAMES128TO255OCTETS       0x0190
-#define TITAN_GE_MSTATX_RXFRAMES256TO511OCTETS       0x01A0
-#define TITAN_GE_MSTATX_RXFRAMES512TO1023OCTETS      0x01B0
-#define TITAN_GE_MSTATX_RXFRAMES1024TO1518OCTETS     0x01C0
-#define TITAN_GE_MSTATX_RXFRAMES1519TOMAXSIZE        0x01D0
-#define TITAN_GE_MSTATX_RXSTATIONADDRESSFILTERED     0x01E0
-#define TITAN_GE_MSTATX_RXVARIABLE                   0x01F0
-#define TITAN_GE_MSTATX_GENERICADDRESSFILTERED       0x0200
-#define TITAN_GE_MSTATX_UNICASTFILTERED              0x0210
-#define TITAN_GE_MSTATX_MULTICASTFILTERED            0x0220
-#define TITAN_GE_MSTATX_BROADCASTFILTERED            0x0230
-#define TITAN_GE_MSTATX_HASHFILTERED                 0x0240
-#define TITAN_GE_MSTATX_TXFRAMESOK                   0x0250
-#define TITAN_GE_MSTATX_TXOCTETSOK                   0x0260
-#define TITAN_GE_MSTATX_TXOCTETS                     0x0270
-#define TITAN_GE_MSTATX_TXTAGGEDFRAMESOK             0x0280
-#define TITAN_GE_MSTATX_TXMACPAUSECONTROLFRAMESOK    0x0290
-#define TITAN_GE_MSTATX_TXFCSERROR                   0x02A0
-#define TITAN_GE_MSTATX_TXSHORTLENGTHERROR           0x02B0
-#define TITAN_GE_MSTATX_TXLONGLENGTHERROR            0x02C0
-#define TITAN_GE_MSTATX_TXSYSTEMERROR                0x02D0
-#define TITAN_GE_MSTATX_TXMACERROR                   0x02E0
-#define TITAN_GE_MSTATX_TXCARRIERSENSEERROR          0x02F0
-#define TITAN_GE_MSTATX_TXSQETESTERROR               0x0300
-#define TITAN_GE_MSTATX_TXUNICASTFRAMESOK            0x0310
-#define TITAN_GE_MSTATX_TXBROADCASTFRAMESOK          0x0320
-#define TITAN_GE_MSTATX_TXMULTICASTFRAMESOK          0x0330
-#define TITAN_GE_MSTATX_TXUNICASTFRAMESATTEMPTED     0x0340
-#define TITAN_GE_MSTATX_TXBROADCASTFRAMESATTEMPTED   0x0350
-#define TITAN_GE_MSTATX_TXMULTICASTFRAMESATTEMPTED   0x0360
-#define TITAN_GE_MSTATX_TXFRAMES64OCTETS             0x0370
-#define TITAN_GE_MSTATX_TXFRAMES65TO127OCTETS        0x0380
-#define TITAN_GE_MSTATX_TXFRAMES128TO255OCTETS       0x0390
-#define TITAN_GE_MSTATX_TXFRAMES256TO511OCTETS       0x03A0
-#define TITAN_GE_MSTATX_TXFRAMES512TO1023OCTETS      0x03B0
-#define TITAN_GE_MSTATX_TXFRAMES1024TO1518OCTETS     0x03C0
-#define TITAN_GE_MSTATX_TXFRAMES1519TOMAXSIZE        0x03D0
-#define TITAN_GE_MSTATX_TXVARIABLE                   0x03E0
-#define TITAN_GE_MSTATX_RXSYSTEMERROR                0x03F0
-#define TITAN_GE_MSTATX_SINGLECOLLISION              0x0400
-#define TITAN_GE_MSTATX_MULTIPLECOLLISION            0x0410
-#define TITAN_GE_MSTATX_DEFERREDXMISSIONS            0x0420
-#define TITAN_GE_MSTATX_LATECOLLISIONS               0x0430
-#define TITAN_GE_MSTATX_ABORTEDDUETOXSCOLLS          0x0440
-
-/* Interrupt specific defines */
-#define TITAN_GE_DEVICE_ID         0x0000  /* Device ID */
-#define TITAN_GE_RESET             0x0004  /* Reset reg */
-#define TITAN_GE_TSB_CTRL_0        0x000C  /* TSB Control reg 0 */
-#define TITAN_GE_TSB_CTRL_1        0x0010  /* TSB Control reg 1 */
-#define TITAN_GE_INTR_GRP0_STATUS  0x0040  /* General Interrupt Group 0 Status */
-#define TITAN_GE_INTR_XDMA_CORE_A  0x0048  /* XDMA Channel Interrupt Status, Core A*/
-#define TITAN_GE_INTR_XDMA_CORE_B  0x004C  /* XDMA Channel Interrupt Status, Core B*/
-#define	TITAN_GE_INTR_XDMA_IE	   0x0058  /* XDMA Channel Interrupt Enable */
-#define TITAN_GE_SDQPF_ECC_INTR    0x480C  /* SDQPF ECC Interrupt Status */
-#define TITAN_GE_SDQPF_RXFIFO_CTL  0x4828  /* SDQPF RxFifo Control and Interrupt Enb*/
-#define TITAN_GE_SDQPF_RXFIFO_INTR 0x482C  /* SDQPF RxFifo Interrupt Status */
-#define TITAN_GE_SDQPF_TXFIFO_CTL  0x4928  /* SDQPF TxFifo Control and Interrupt Enb*/
-#define TITAN_GE_SDQPF_TXFIFO_INTR 0x492C  /* SDQPF TxFifo Interrupt Status */
-#define	TITAN_GE_SDQPF_RXFIFO_0	   0x4840  /* SDQPF RxFIFO Enable */
-#define	TITAN_GE_SDQPF_TXFIFO_0	   0x4940  /* SDQPF TxFIFO Enable */
-#define TITAN_GE_XDMA_CONFIG       0x5000  /* XDMA Global Configuration */
-#define TITAN_GE_XDMA_INTR_SUMMARY 0x5010  /* XDMA Interrupt Summary */
-#define TITAN_GE_XDMA_BUFADDRPRE   0x5018  /* XDMA Buffer Address Prefix */
-#define TITAN_GE_XDMA_DESCADDRPRE  0x501C  /* XDMA Descriptor Address Prefix */
-#define TITAN_GE_XDMA_PORTWEIGHT   0x502C  /* XDMA Port Weight Configuration */
-
-/* Rx MAC defines */
-#define TITAN_GE_RMAC_CONFIG_1               0x1200  /* RMAC Configuration 1 */
-#define TITAN_GE_RMAC_CONFIG_2               0x1204  /* RMAC Configuration 2 */
-#define TITAN_GE_RMAC_MAX_FRAME_LEN          0x1208  /* RMAC Max Frame Length */
-#define TITAN_GE_RMAC_STATION_HI             0x120C  /* Rx Station Address High */
-#define TITAN_GE_RMAC_STATION_MID            0x1210  /* Rx Station Address Middle */
-#define TITAN_GE_RMAC_STATION_LOW            0x1214  /* Rx Station Address Low */
-#define TITAN_GE_RMAC_LINK_CONFIG            0x1218  /* RMAC Link Configuration */
-
-/* Tx MAC defines */
-#define TITAN_GE_TMAC_CONFIG_1               0x1240  /* TMAC Configuration 1 */
-#define TITAN_GE_TMAC_CONFIG_2               0x1244  /* TMAC Configuration 2 */
-#define TITAN_GE_TMAC_IPG                    0x1248  /* TMAC Inter-Packet Gap */
-#define TITAN_GE_TMAC_STATION_HI             0x124C  /* Tx Station Address High */
-#define TITAN_GE_TMAC_STATION_MID            0x1250  /* Tx Station Address Middle */
-#define TITAN_GE_TMAC_STATION_LOW            0x1254  /* Tx Station Address Low */
-#define TITAN_GE_TMAC_MAX_FRAME_LEN          0x1258  /* TMAC Max Frame Length */
-#define TITAN_GE_TMAC_MIN_FRAME_LEN          0x125C  /* TMAC Min Frame Length */
-#define TITAN_GE_TMAC_PAUSE_FRAME_TIME       0x1260  /* TMAC Pause Frame Time */
-#define TITAN_GE_TMAC_PAUSE_FRAME_INTERVAL   0x1264  /* TMAC Pause Frame Interval */
-
-/* GMII register */
-#define TITAN_GE_GMII_INTERRUPT_STATUS       0x1348  /* GMII Interrupt Status */
-#define TITAN_GE_GMII_CONFIG_GENERAL         0x134C  /* GMII Configuration General */
-#define TITAN_GE_GMII_CONFIG_MODE            0x1350  /* GMII Configuration Mode */
-
-/* Tx and Rx XDMA defines */
-#define	TITAN_GE_INT_COALESCING		     0x5030 /* Interrupt Coalescing */
-#define	TITAN_GE_CHANNEL0_CONFIG	     0x5040 /* Channel 0 XDMA config */
-#define	TITAN_GE_CHANNEL0_INTERRUPT	     0x504c /* Channel 0 Interrupt Status */
-#define	TITAN_GE_GDI_INTERRUPT_ENABLE        0x5050 /* IE for the GDI Errors */
-#define	TITAN_GE_CHANNEL0_PACKET	     0x5060 /* Channel 0 Packet count */
-#define	TITAN_GE_CHANNEL0_BYTE		     0x5064 /* Channel 0 Byte count */
-#define	TITAN_GE_CHANNEL0_TX_DESC	     0x5054 /* Channel 0 Tx first desc */
-#define	TITAN_GE_CHANNEL0_RX_DESC	     0x5058 /* Channel 0 Rx first desc */
-
-/* AFX (Address Filter Exact) register offsets for Slice 0 */
-#define TITAN_GE_AFX_EXACT_MATCH_LOW         0x1100  /* AFX Exact Match Address Low*/
-#define TITAN_GE_AFX_EXACT_MATCH_MID         0x1104  /* AFX Exact Match Address Mid*/
-#define TITAN_GE_AFX_EXACT_MATCH_HIGH        0x1108  /* AFX Exact Match Address Hi */
-#define TITAN_GE_AFX_EXACT_MATCH_VID         0x110C  /* AFX Exact Match VID */
-#define TITAN_GE_AFX_MULTICAST_HASH_LOW      0x1110  /* AFX Multicast HASH Low */
-#define TITAN_GE_AFX_MULTICAST_HASH_MIDLOW   0x1114  /* AFX Multicast HASH MidLow */
-#define TITAN_GE_AFX_MULTICAST_HASH_MIDHI    0x1118  /* AFX Multicast HASH MidHi */
-#define TITAN_GE_AFX_MULTICAST_HASH_HI       0x111C  /* AFX Multicast HASH Hi */
-#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_0     0x1120  /* AFX Address Filter Ctrl 0 */
-#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_1     0x1124  /* AFX Address Filter Ctrl 1 */
-#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_2     0x1128  /* AFX Address Filter Ctrl 2 */
-
-/* Traffic Groomer block */
-#define        TITAN_GE_TRTG_CONFIG	     0x1000  /* TRTG Config */
-
-#endif 				/* _TITAN_GE_H_ */
-
diff -Naur linux-3.5.4/drivers/net/ethernet/pmc-sierra/titan_mdio.c linux-2012.09/drivers/net/ethernet/pmc-sierra/titan_mdio.c
--- linux-3.5.4/drivers/net/ethernet/pmc-sierra/titan_mdio.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/drivers/net/ethernet/pmc-sierra/titan_mdio.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,217 +0,0 @@
-/*
- * drivers/net/titan_mdio.c - Driver for Titan ethernet ports
- *
- * Copyright (C) 2003 PMC-Sierra Inc.
- * Author : Manish Lachwani (lachwani@pmc-sierra.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- *
- * Management Data IO (MDIO) driver for the Titan GMII. Interacts with the Marvel PHY
- * on the Titan. No support for the TBI as yet.
- *
- */
-
-#include	"titan_mdio.h"
-
-#define MDIO_DEBUG
-
-/*
- * Local constants
- */
-#define MAX_CLKA            1023
-#define MAX_PHY_DEV         31
-#define MAX_PHY_REG         31
-#define WRITEADDRS_OPCODE   0x0
-#define	READ_OPCODE	    0x2
-#define WRITE_OPCODE        0x1
-#define MAX_MDIO_POLL       100
-
-/*
- * Titan MDIO and SCMB registers
- */
-#define TITAN_GE_SCMB_CONTROL                0x01c0  /* SCMB Control */
-#define TITAN_GE_SCMB_CLKA	             0x01c4  /* SCMB Clock A */
-#define TITAN_GE_MDIO_COMMAND                0x01d0  /* MDIO Command */
-#define TITAN_GE_MDIO_DEVICE_PORT_ADDRESS    0x01d4  /* MDIO Device and Port addrs */
-#define TITAN_GE_MDIO_DATA                   0x01d8  /* MDIO Data */
-#define TITAN_GE_MDIO_INTERRUPTS             0x01dC  /* MDIO Interrupts */
-
-/*
- * Function to poll the MDIO
- */
-static int titan_ge_mdio_poll(void)
-{
-	int	i, val;
-
-	for (i = 0; i < MAX_MDIO_POLL; i++) {
-		val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
-
-		if (!(val & 0x8000))
-			return TITAN_GE_MDIO_GOOD;
-	}
-
-	return TITAN_GE_MDIO_ERROR;
-}
-
-
-/*
- * Initialize and configure the MDIO
- */
-int titan_ge_mdio_setup(titan_ge_mdio_config *titan_mdio)
-{
-	unsigned long	val;
-
-	/* Reset the SCMB and program into MDIO mode*/
-	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x9000);
-	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x1000);
-
-	/* CLK A */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_SCMB_CLKA);
-	val = ( (val & ~(0x03ff)) | (titan_mdio->clka & 0x03ff));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CLKA, val);
-
-	/* Preamble Suppresion */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
-	val = ( (val & ~(0x0001)) | (titan_mdio->mdio_spre & 0x0001));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
-
-	/* MDIO mode */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
-	val = ( (val & ~(0x4000)) | (titan_mdio->mdio_mode & 0x4000));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
-
-	return TITAN_GE_MDIO_GOOD;
-}
-
-/*
- * Set the PHY address in indirect mode
- */
-int titan_ge_mdio_inaddrs(int dev_addr, int reg_addr)
-{
-	volatile unsigned long	val;
-
-	/* Setup the PHY device */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
-	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
-	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
-
-	/* Write the new address */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
-	val = ( (val & ~(0x0300)) | ( (WRITEADDRS_OPCODE << 8) & 0x0300));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
-
-	return TITAN_GE_MDIO_GOOD;
-}
-
-/*
- * Read the MDIO register. This is what the individual parametes mean:
- *
- * dev_addr : PHY ID
- * reg_addr : register offset
- *
- * See the spec for the Titan MAC. We operate in the Direct Mode.
- */
-
-#define MAX_RETRIES	2
-
-int titan_ge_mdio_read(int dev_addr, int reg_addr, unsigned int *pdata)
-{
-	volatile unsigned long	val;
-	int retries = 0;
-
-	/* Setup the PHY device */
-
-again:
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
-	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
-	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
-	val |= 0x4000;
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
-
-	udelay(30);
-
-	/* Issue the read command */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
-	val = ( (val & ~(0x0300)) | ( (READ_OPCODE << 8) & 0x0300));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
-
-	udelay(30);
-
-	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
-		return TITAN_GE_MDIO_ERROR;
-
-	*pdata = (unsigned int)TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DATA);
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);
-
-	udelay(30);
-
-	if (val & 0x2) {
-		if (retries == MAX_RETRIES)
-			return TITAN_GE_MDIO_ERROR;
-		else {
-			retries++;
-			goto again;
-		}
-	}
-
-	return TITAN_GE_MDIO_GOOD;
-}
-
-/*
- * Write to the MDIO register
- *
- * dev_addr : PHY ID
- * reg_addr : register that needs to be written to
- *
- */
-int titan_ge_mdio_write(int dev_addr, int reg_addr, unsigned int data)
-{
-	volatile unsigned long	val;
-
-	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
-		return TITAN_GE_MDIO_ERROR;
-
-	/* Setup the PHY device */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
-	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
-	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
-	val |= 0x4000;
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
-
-	udelay(30);
-
-	/* Setup the data to write */
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DATA, data);
-
-	udelay(30);
-
-	/* Issue the write command */
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
-	val = ( (val & ~(0x0300)) | ( (WRITE_OPCODE << 8) & 0x0300));
-	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
-
-	udelay(30);
-
-	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
-		return TITAN_GE_MDIO_ERROR;
-
-	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);
-	if (val & 0x2)
-		return TITAN_GE_MDIO_ERROR;
-
-	return TITAN_GE_MDIO_GOOD;
-}
-
diff -Naur linux-3.5.4/drivers/net/ethernet/pmc-sierra/titan_mdio.h linux-2012.09/drivers/net/ethernet/pmc-sierra/titan_mdio.h
--- linux-3.5.4/drivers/net/ethernet/pmc-sierra/titan_mdio.h	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/drivers/net/ethernet/pmc-sierra/titan_mdio.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,56 +0,0 @@
-/*
- * MDIO used to interact with the PHY when using GMII/MII
- */
-#ifndef _TITAN_MDIO_H
-#define _TITAN_MDIO_H
-
-#include <linux/netdevice.h>
-#include <linux/workqueue.h>
-#include <linux/delay.h>
-#include "titan_ge.h"
-
-
-#define	TITAN_GE_MDIO_ERROR	(-9000)
-#define	TITAN_GE_MDIO_GOOD	0
-
-#define	TITAN_GE_MDIO_BASE		titan_ge_base
-
-#define	TITAN_GE_MDIO_READ(offset)	\
-	*(volatile u32 *)(titan_ge_base + (offset))
-
-#define	TITAN_GE_MDIO_WRITE(offset, data)	\
-	*(volatile u32 *)(titan_ge_base + (offset)) = (data)
-
-
-/* GMII specific registers */
-#define	TITAN_GE_MARVEL_PHY_ID		0x00
-#define	TITAN_PHY_AUTONEG_ADV		0x04
-#define	TITAN_PHY_LP_ABILITY		0x05
-#define	TITAN_GE_MDIO_MII_CTRL		0x09
-#define	TITAN_GE_MDIO_MII_EXTENDED	0x0f
-#define	TITAN_GE_MDIO_PHY_CTRL		0x10
-#define	TITAN_GE_MDIO_PHY_STATUS	0x11
-#define	TITAN_GE_MDIO_PHY_IE		0x12
-#define	TITAN_GE_MDIO_PHY_IS		0x13
-#define	TITAN_GE_MDIO_PHY_LED		0x18
-#define	TITAN_GE_MDIO_PHY_LED_OVER	0x19
-#define	PHY_ANEG_TIME_WAIT		45	/* 45 seconds wait time */
-
-/*
- * MDIO Config Structure
- */
-typedef struct {
-	unsigned int		clka;
-	int			mdio_spre;
-	int			mdio_mode;
-} titan_ge_mdio_config;
-
-/*
- * Function Prototypes
- */
-int titan_ge_mdio_setup(titan_ge_mdio_config *);
-int titan_ge_mdio_inaddrs(int, int);
-int titan_ge_mdio_read(int, int, unsigned int *);
-int titan_ge_mdio_write(int, int, unsigned int);
-
-#endif /* _TITAN_MDIO_H */
diff -Naur linux-3.5.4/drivers/video/console/newport_con.c linux-2012.09/drivers/video/console/newport_con.c
--- linux-3.5.4/drivers/video/console/newport_con.c	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/drivers/video/console/newport_con.c	2012-10-27 16:24:23.000000000 +0800
@@ -327,16 +327,9 @@
 
 static void newport_init(struct vc_data *vc, int init)
 {
-	int cols, rows;
-
-	cols = newport_xsize / 8;
-	rows = newport_ysize / 16;
+	vc->vc_cols = newport_xsize / 8;
+	vc->vc_rows = newport_ysize / 16;
 	vc->vc_can_do_color = 1;
-	if (init) {
-		vc->vc_cols = cols;
-		vc->vc_rows = rows;
-	} else
-		vc_resize(vc, cols, rows);
 }
 
 static void newport_deinit(struct vc_data *c)
diff -Naur linux-3.5.4/include/linux/a.out.h linux-2012.09/include/linux/a.out.h
--- linux-3.5.4/include/linux/a.out.h	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/include/linux/a.out.h	2012-10-27 16:24:12.000000000 +0800
@@ -129,7 +129,6 @@
 #define SEGMENT_SIZE PAGE_SIZE
 #endif
 
-#ifdef linux
 #ifdef __KERNEL__
 #include <asm/page.h>
 #else
@@ -146,7 +145,6 @@
 #endif
 #endif
 #endif
-#endif
 
 #define _N_SEGMENT_ROUND(x) ALIGN(x, SEGMENT_SIZE)
 
diff -Naur linux-3.5.4/Makefile linux-2012.09/Makefile
--- linux-3.5.4/Makefile	2012-09-16 15:10:11.000000000 +0800
+++ linux-2012.09/Makefile	2012-10-27 16:24:42.000000000 +0800
@@ -192,7 +192,7 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= mips
+ARCH		?= $(SUBARCH)
 CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
 
 # Architecture as present in compile.h
diff -Naur linux-3.5.4/release-notes-csl.xml linux-2012.09/release-notes-csl.xml
--- linux-3.5.4/release-notes-csl.xml	1970-01-01 08:00:00.000000000 +0800
+++ linux-2012.09/release-notes-csl.xml	2012-10-27 16:24:42.000000000 +0800
@@ -0,0 +1,95 @@
+<!-- This file contains a series of release note fragments processed
+     by gnu-notes.  To add a note to it, use "gnu-notes -a
+     $release_config linux".  The TARGET line should contain a
+     list of shell glob patterns for target names to which the note is
+     relevant; it may be removed if it is relevant to all targets.
+ -->
+
+      <!-- UUID: 2cd74727-cc83-438b-917f-cd4bac897114 -->
+      <!-- TARGET: * -->
+      <!-- SORT: libraries -->
+      <!-- ISSUE: -->
+      <formalpara>
+        <title>Linux kernel headers update</title>
+        <para>
+          Linux kernel header files have been updated to version
+          3.5.4.
+        </para>
+      </formalpara>
+
+      <!-- UUID: da45780f-2cb4-4886-9d2d-a61a0226f063 -->
+      <!-- TARGET: * -->
+      <!-- SORT: libraries -->
+      <!-- ISSUE: -->
+      <formalpara>
+        <title>Linux kernel headers update</title>
+        <para>
+          Linux kernel header files have been updated to version
+          3.2.10.
+        </para>
+      </formalpara>
+
+      <!-- UUID: c11e7074-c89e-41c8-9c07-8ac1c5bfcc08 -->
+      <!-- TARGET: * -->
+      <formalpara>
+        <title>Linux kernel headers update</title>
+        <para>
+          Linux kernel header files have been updated to version
+          3.0.1.
+        </para>
+      </formalpara>
+
+      <!-- UUID: 80058800-d4dd-4eef-a7ce-0a558fe5d497 -->
+      <!-- TARGET: * -->
+      <formalpara>
+        <title>Linux kernel headers update</title>
+        <para>
+          Linux kernel header files have been updated to version
+          2.6.39.
+        </para>
+      </formalpara>
+
+      <!-- UUID: 42091cef-5a4b-4932-a6d9-b221573ad5b5 -->
+      <!-- TARGET: * -->
+      <formalpara>
+        <title>Linux kernel headers update</title>
+        <para>
+          Linux kernel header files have been updated to version
+          2.6.38.
+        </para>
+      </formalpara>
+
+      <!-- UUID: d84d82cb-fe46-4df6-970e-112f167c304a -->
+      <!-- TARGET: * -->
+      <formalpara>
+        <title>Linux kernel headers update</title>
+        <para>
+          Linux kernel header files have been updated to version
+          2.6.35.2.
+        </para>
+      </formalpara>
+
+      <!-- UUID: ac193e5e-a41e-40bb-a696-5bc4b5d3368c -->
+      <!-- TARGET: *montavista* -->
+      <formalpara>
+        <title>Linux kernel headers update</title>
+        <para>
+          Linux kernel header files have been updated to version 2.6.32 to
+          fix a problem involving tc_drr_stats in pkt_sched.h using u32
+          instead of __u32 (MontaVista bug 38116).
+        </para>
+      </formalpara>
+
+      <!-- UUID: bad6e9bf-5070-4c46-be04-a96c2e5d6128 -->
+      <!-- TARGET: * -->
+      <formalpara>
+        <title>Linux kernel headers update</title>
+        <para>
+          Linux kernel header files have been updated to version 2.6.30.
+	  <phrase target-arch="m68k">Among other things this fixes
+	    assembler failures with functions that convert integers
+	    to different endianness.</phrase>
+        </para>
+      </formalpara>
+
+<!-- Release notes end here.  -->
